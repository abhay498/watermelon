
1. https://www.journaldev.com/23647/python-reverse-string

2. User-defined functions vs. Built-in / Pre-defined functions
   https://stackoverflow.com/questions/17159904/user-defined-functions-vs-built-in-pre-defined-functions

3.   https://docs.python.org/3/glossary.html

4. Algorithms and their time complexities
      --- Refer drive
 
4. https://www.python-course.eu/python3_deep_copy.php

5. https://medium.com/@meghamohan/mutable-and-immutable-side-of-python-c2145cf72747

6. https://medium.com/@george.seif94/a-tour-of-the-top-5-sorting-algorithms-with-python-code-43ea9aa02889
    [Sorting algorithms]

7. Built-in String Methods

	# count(str, beg= 0, end=len(string)) --> Counts how many times str occurs in string or in a substring of
                                          string if starting index beg and ending index end are given.
	# endswith(suffix, beg=0, end=len(string)) --> Determines if string or a substring of string (if starting index
					       beg and ending index end are given) ends with suffix; returns true
					       if so and false otherwise.
	# index(str, beg=0, end=len(string)) --> Determine if str occurs in string or in a substring of string if starting
				       index beg and ending index end are given returns index if found and raises an exception if str not found.
        # join(seq) --> Merges (concatenates) the string representations of elements in sequence seq into a string, with separator string.
	# len(string) --> Returns the length of the string
        # replace(old, new [, max]) --> Replaces all occurrences of old in string with new or at most max occurrences if max given.
        # split(str="", num=string.count(str)) --> Splits string according to delimiter str (space if not provided) and returns list of substrings;
	                                           split into at most num substrings if given.
        # startswith(str, beg=0,end=len(string)) --> Determines if string or a substring of string (if starting index beg and ending index end are given)
	                                             starts with substring str; returns true if so and false otherwise.
        # strip([chars]) --> Performs both lstrip() and rstrip() on string.

        # Examples : 

	      b.
	      string = 'Abhi is smart, he is, intelligent'
	      count_1= string.count('is')
              print(count_1)
	      
	      o/p:
	        >>> 
		================ RESTART: C:\Users\Abhay\OneDrive\Desktop\one.py ===============
		2
		>>> 

	      c.
	    
		string = 'nuggets of nuggets.'

		string_2 = string.endswith('of nuggets')
		print(string_2)

		string_2= string.endswith('nuggets.')
		print(string_2)

		string_2= string.endswith('nuggets of nuggets.')
		print(string_2)

              o/p:
	        >>> 
		================ RESTART: C:\Users\Abhay\OneDrive\Desktop\one.py ===============
		False
		True
		True
		>>> 

	     f.
	     
		string = 'nuggets of nuggets.'
		string_2 = 'shyam'

		print(string.index('nuggets'))
		print(string.index('of'))

		result = string.index(string_2)
		print('result is {}'.format(result))

		o/p:
		>>> 
		================ RESTART: C:\Users\Abhay\OneDrive\Desktop\one.py ===============
		0
		8
		Traceback (most recent call last):
		  File "C:\Users\Abhay\OneDrive\Desktop\one.py", line 8, in <module>
		    result = string.index(string_2)
		ValueError: substring not found
		>>> 

	      g.
	      
		list_1 = ['1' ,'2', '3', '4']
		string = '-'

		print(string.join(list_1))
		print(string)

		o/p:

		>>> 
		================ RESTART: C:\Users\Abhay\OneDrive\Desktop\one.py ===============
		1-2-3-4
		-
		>>> 
              
	       ##########################################
	       
	       list_1 = ['n', 'u', 'g', 'g', 'e', 't', 's']
	       print(''.join(list_1))

		o/p:
		
	        >>> 
		================ RESTART: C:\Users\Abhay\OneDrive\Desktop\one.py ===============
		nuggets
		>>> 
		
		h.
		string = 'nuggets of nuggets'
		print(len(string))

		>>> 
		================ RESTART: C:\Users\Abhay\OneDrive\Desktop\one.py ===============
		18
		>>> 

		i.
		string = 'nuggets of nuggets of nuggets'

		print(string.replace('nuggets', 'shyam'))
		print(string.replace('nuggets', 'shyam', 2))

		print(string.replace('n', 'b'))
		print(string.replace('n', 'b', 2))

		o/p:

		>>> 
		================ RESTART: C:\Users\Abhay\OneDrive\Desktop\one.py ===============
		shyam of shyam of shyam
		shyam of shyam of nuggets
		buggets of buggets of buggets
		buggets of buggets of nuggets
		>>> 
		
		j.
		string = 'nuggets of nuggets'
		print(string.split())

		string = 'nuggets, of, nuggets'
		print(string.split(','))

		string = 'nuggets:of:nuggets'
		print(string.split(':'))

		string = 'CatBatSatOr'
		print(string.split('t'))

		o/p:

		>>> 
		================ RESTART: C:\Users\Abhay\OneDrive\Desktop\one.py ===============
		['nuggets', 'of', 'nuggets']
		['nuggets', ' of', ' nuggets']
		['nuggets', 'of', 'nuggets']
		['Ca', 'Ba', 'Sa', 'Or']
		>>> 

		##################################################################################

		k.

		string = 'nuggets:of:nuggets:shyam:ram:hurricane'

		print(string.split(':', 0))
		print(string.split(':', 3))
		print(string.split(':', 7))

		o/p:

		>>> 
		================ RESTART: C:\Users\Abhay\OneDrive\Desktop\one.py ===============
		['nuggets:of:nuggets:shyam:ram:hurricane']
		['nuggets', 'of', 'nuggets', 'shyam:ram:hurricane']
		['nuggets', 'of', 'nuggets', 'shyam', 'ram', 'hurricane']
		>>> 

 		l.
		
		string = 'nuggetsofnuggets'

		print(string.startswith('nuggets'))
		print(string.startswith('nuggets', 9, 10))
		print(string.startswith('nuggets', 9, 20))

		o/p:
		
		>>> 
		================ RESTART: C:\Users\Abhay\OneDrive\Desktop\one.py ===============
		True
		False
		True
		>>> 

		######################################################################
		
		m.

		string = ' nuggets of nuggets '
		string_2 = 'etsn '

		print(string.strip())
		print(string.strip(' nuggets'))
		print(string.strip(string_2))
		print(string)


		string_3 = ' the King has the largest army in the entire world the'
		print(string_3.strip(' the'))

		string_4 = 'nuggets of nuggets'
		string_5 = 'ugetns'
		print(string_4.strip(string_5))

		o/p:

		>>> 
		================ RESTART: C:\Users\Abhay\OneDrive\Desktop\one.py ===============
		nuggets of nuggets
		of
		uggets of nugg
		 nuggets of nuggets 
		King has the largest army in the entire world
		 of 
		>>> 


8. Built-in List Functions & Methods

	# len(list) --> Gives the total length of the list.
	# max(list) --> Returns item from the list with max value.
        # min(list) --> Returns item from the list with min value.
        # list(seq) --> Converts a tuple into list.
	# list.append(obj) --> Appends object obj to list
        # list.count(obj) --> Returns count of how many times obj occurs in list
        # list.extend(seq) --> Appends the contents of seq to list
        # list.index(obj) --> Returns the lowest index in list that obj appears
	# list.insert(index, obj) --> Inserts object obj into list at offset index
	# list.pop(obj=list[-1]) --> Removes and returns last object or obj from list
	# list.remove(obj) --> Removes object obj from list
	# list.reverse() --> Reverses objects of list in place
	# list.sort([func]) --> Sorts objects of list, use compare func if given

		a.
		list_a = ['Hello', 'Edureka', 1, 2, 3]
		print ('Number of items in the list = ', len(list_a))

		o/p:
		>>> 
		================ RESTART: C:\Users\Abhay\OneDrive\Desktop\one.py ===============
		Number of items in the list =  5
		>>> 

		b.
		list_a = [10, 20, 4, 45, 99]
		print("Largest element is:", max(list_a))

		o/p
		>>> 
		================ RESTART: C:\Users\Abhay\OneDrive\Desktop\one.py ===============
		Largest element is: 99
		>>> 

		c.
		list_a = [10, 20, 4, 45, 99]
		print("Smallest element is:", min(list_a))

		o/p:

		>>> 
		================ RESTART: C:\Users\Abhay\OneDrive\Desktop\one.py ===============
		Smallest element is: 4
		>>> 

		d.
		tuple_a = (True, 28, 'Tiger')
		list_a = list(tuple_a)
		print(type(list_a))
		print(type(tuple_a))
		print(list_a)

		o/p:

		>>> 
		================ RESTART: C:\Users\Abhay\OneDrive\Desktop\one.py ===============
		<class 'list'>
		<class 'tuple'>
		[True, 28, 'Tiger']
		>>> 

		e.

		Time Complexity:
		Append has constant time complexity i.e.,O(1).
		Extend has time complexity of O(k). Where k is the length of list which need to be added.

		my_list = ['nuggets', 'for']
		my_list.append('Abhay')
		print (my_list)

		o/p:

		>>> 
		================ RESTART: C:\Users\Abhay\OneDrive\Desktop\one.py ===============
		['nuggets', 'for', 'Abhay']
		>>> 

		#####################################

		my_list = ['geeks', 'for', 'geeks']
		another_list = [6, 0, 4, 1]
		my_list.append(another_list)
		print (my_list)

		o/p:
		>>> 
		================ RESTART: C:\Users\Abhay\OneDrive\Desktop\one.py ===============
		['geeks', 'for', 'geeks', [6, 0, 4, 1]]
		>>> 

		#####################################

		my_list = ['geeks', 'for']
		another_list = [6, 0, 4, 1]
		my_list.extend(another_list)
		print (my_list)

		o/p:
		>>> 
		================ RESTART: C:\Users\Abhay\OneDrive\Desktop\one.py ===============
		['geeks', 'for', 6, 0, 4, 1]
		>>> 

		#####################################
		my_list = ['geeks', 'for', 6, 0, 4, 1]
		my_list.extend('geeks')
		print(my_list)

		o/p:

		>>> 
		================ RESTART: C:\Users\Abhay\OneDrive\Desktop\one.py ===============
		['geeks', 'for', 6, 0, 4, 1, 'g', 'e', 'e', 'k', 's']
		>>> 

		f. 

		list1 = [1, 1, 1, 2, 3, 2, 1]
		print(list1.count(1))

		>>> 
		================ RESTART: C:\Users\Abhay\OneDrive\Desktop\one.py ===============
		4
		>>> 


		g.

		list_a = [1, 2, 3, 4, 1, 1, 1, 4, 5]
		print(list_a.index(4))

		o/p:

		>>> 
		================ RESTART: C:\Users\Abhay\OneDrive\Desktop\one.py ===============
		3
		>>> 

		h.

		list_a = [ 1, 2, 3, 4, 5, 6, 7 ]
		list_a.insert(4, 10)
		print(list_a)

		o/p:
		>>> 
		================ RESTART: C:\Users\Abhay\OneDrive\Desktop\one.py ===============
		[1, 2, 3, 4, 10, 5, 6, 7]
		>>> 

		i.

		list_a = [ 1, 2, 3, 4, 5, 6 ]
		popped = list_a.pop()
		print('popped = ', popped)
		print('list is = ', list_a)

		list_b = [ 10, 20, 30, 40, 50, 60, 70]
		popped = list_b.pop(-2)
		print('popped = ', popped)
		print('list is = ', list_b)

		o/p:
		>>> 
		================ RESTART: C:\Users\Abhay\OneDrive\Desktop\one.py ===============
		popped =  6
		list is =  [1, 2, 3, 4, 5]
		popped =  60
		list is =  [10, 20, 30, 40, 50, 70]
		>>> 

		j.

		list_a = [ 1, 2, 1, 1, 4, 5 ]
		list_a.remove(1)
		print(list_a)

		>>> 
		================ RESTART: C:\Users\Abhay\OneDrive\Desktop\one.py ===============
		[2, 1, 1, 4, 5]
		>>> 

		k.

		list_a = [1, 2, 3, 4, 5, 6]

		reversed_list_a = [x for x in reversed(list_a)]
		print(reversed_list_a)
		print(list_a)

		list_b = [10, 20 , 30, 40 , 50]
		list_b.reverse()
		print(list_b)

		o/p:
		>>> 
		================ RESTART: C:\Users\Abhay\OneDrive\Desktop\one.py ===============
		[6, 5, 4, 3, 2, 1]
		[1, 2, 3, 4, 5, 6]
		[50, 40, 30, 20, 10]
		>>> 

		l.

		numbers = [1, 3, 4, 2]
		numbers.sort()
		print(numbers)
		numbers.sort(reverse=True)
		print(numbers)

		o/p:

		>>> 
		================ RESTART: C:\Users\Abhay\OneDrive\Desktop\one.py ===============
		[1, 2, 3, 4]
		[4, 3, 2, 1]
		>>> 

10. Built-in Dictionary Functions & Methods

# len(dict) --> Gives the total length of the dictionary. This would be equal to the number of items in the dictionary.
# dict.clear()
# dict.copy() --> Returns a shallow copy of dictionary dict
# dict.fromkeys() --> Create a new dictionary with keys from seq and values set to value.
# dict.get(key, default=None) --> For key key, returns value or default if key not in dictionary
# dict.items() --> Returns a list of dict's (key, value) tuple pairs
# dict.keys() --> Returns list of dictionary dict's keys
# dict.update(dict2) --> Adds dictionary dict2's key-values pairs to dict
# dict.values() --> Returns list of dictionary dict's values


		a.
		dict1 ={'Name':'Steve', 'Age':30, 'Designation':'Programmer'}
		print("len() method :", len(dict1))
		print("len() method with keys() :", len(dict1.keys()))
		print("len() method with values():", len(dict1.values()))

		o/p:
		>>> 
		================ RESTART: C:\Users\Abhay\OneDrive\Desktop\one.py ===============
		len() method : 3
		len() method with keys() : 3
		len() method with values(): 3
		>>> 

		b.
		text1 = {1: "geeks", 2: "for"}
		text2 = text1
		text1.clear()

		print('After removing items using clear()')
		print('text1 =', text1)
		print('text2 =', text2)

		print('##################################')

		text1 = {1: "one", 2: "two"}
		text2 = text1


		text1 = {}

		print('After removing items by assigning {}')
		print('text1 =', text1)
		print('text2 =', text2)

		o/p:

		>>> 
		================ RESTART: C:\Users\Abhay\OneDrive\Desktop\one.py ===============
		After removing items using clear()
		text1 = {}
		text2 = {}
		##################################
		After removing items by assigning {}
		text1 = {}
		text2 = {1: 'one', 2: 'two'}
		>>> 

		c.

		original = {1:'geeks', 2:'for'}
		new = original.copy()
		new.clear()
		print('new: ', new)
		print('original: ', original)

		print('###########################')

		original = {1:'one', 2:'two'}
		new = original
		new.clear()
		print('new: ', new)
		print('original: ', original)

		o/p:
		>>> 
		================ RESTART: C:\Users\Abhay\OneDrive\Desktop\one.py ===============
		new:  {}
		original:  {1: 'geeks', 2: 'for'}
		###########################
		new:  {}
		original:  {}
		>>> 

		d.
		seq = {'a', 'b', 'c', 'd', 'e'}
		res_dict = dict.fromkeys(seq)
		print(res_dict)
		res_dict2 = dict.fromkeys(seq, 1)
		print(res_dict2)

		>>> 
		================ RESTART: C:\Users\Abhay\OneDrive\Desktop\one.py ===============
		{'c': None, 'a': None, 'e': None, 'd': None, 'b': None}
		{'c': 1, 'a': 1, 'e': 1, 'd': 1, 'b': 1}
		>>> 

		e.
		dic = {"A":1, "B":2}
		print(dic.get("A"))
		print(dic.get("C"))

		o/p:
		>>> 
		================ RESTART: C:\Users\Abhay\OneDrive\Desktop\one.py ===============
		1
		None
		>>> 

		f.
		Dictionary1 = { 'A': 'Geeks', 'B': 4, 'C': 'Geeks' }
		print("Original Dictionary items:")
		items = Dictionary1.items()
		print(items)
		del [Dictionary1['C']]
		print('Updated Dictionary:')
		print(items)

		o/p:
		>>> 
		================ RESTART: C:\Users\Abhay\OneDrive\Desktop\one.py ===============
		Original Dictionary items:
		dict_items([('A', 'Geeks'), ('B', 4), ('C', 'Geeks')])
		Updated Dictionary:
		dict_items([('A', 'Geeks'), ('B', 4)])
		>>> 

		##################

		a_dict = {'color': 'blue', 'fruit': 'apple', 'pet': 'dog'}
		d_items = a_dict.items()
		print(d_items)

		for item in a_dict.items():
			print(item)
			print(type(item))

		for key, value in a_dict.items():
			print(key, '->', value)
			
		o/p:
		>>> 
		================ RESTART: C:\Users\Abhay\OneDrive\Desktop\one.py ===============
		dict_items([('color', 'blue'), ('fruit', 'apple'), ('pet', 'dog')])
		('color', 'blue')
		<class 'tuple'>
		('fruit', 'apple')
		<class 'tuple'>
		('pet', 'dog')
		<class 'tuple'>
		color -> blue
		fruit -> apple
		pet -> dog
		>>> 

		g.
		a_dict = {'color': 'blue', 'fruit': 'apple', 'pet': 'dog'}
		keys = a_dict.keys()
		print(keys)

		for key in a_dict.keys():
			print(key, '->', a_dict[key])
			
		o/p:
		>>> 
		================ RESTART: C:\Users\Abhay\OneDrive\Desktop\one.py ===============
		dict_keys(['color', 'fruit', 'pet'])
		color -> blue
		fruit -> apple
		pet -> dog
		>>> 

		h.
		dictionary_one = { 'A': 'Geeks', 'B': 'For'}
		dictionary_two = { 'B': 'Geeks' }

		print("Original Dictionary:")
		print(dictionary_one)

		dictionary_one.update(dictionary_two)
		print("Dictionary after updation:")
		print(dictionary_one)

		dictionary_one.update(C = 'Geeks', D = 'clock')
		print("Dictionary after updation:")
		print(dictionary_one)

		o/p:
		>>> 
		================ RESTART: C:\Users\Abhay\OneDrive\Desktop\one.py ===============
		Original Dictionary:
		{'A': 'Geeks', 'B': 'For'}
		Dictionary after updation:
		{'A': 'Geeks', 'B': 'Geeks'}
		Dictionary after updation:
		{'A': 'Geeks', 'B': 'Geeks', 'C': 'Geeks', 'D': 'clock'}
		>>> 

		i.

		a_dict = {'color': 'blue', 'fruit': 'apple', 'pet': 'dog'}
		values = a_dict.values()
		print(values)

		for value in a_dict.values():
			print(value)
			
		o/p:

		>>> 
		================ RESTART: C:\Users\Abhay\OneDrive\Desktop\one.py ===============
		dict_values(['blue', 'apple', 'dog'])
		blue
		apple
		dog
		>>> 

		#############################################

		>>> a_dict = {'color': 'blue', 'fruit': 'apple', 'pet': 'dog'}
		>>> 'pet' in a_dict.keys()
		True
		>>> 'apple' in a_dict.values()
		True
		>>> 'onion' in a_dict.values()
		False

		#############################################

		>>> a_dict = {'one': 1, 'two': 2, 'thee': 3, 'four': 4}
		>>> new_dict = {}
		>>> for key, value in a_dict.items():
		...     new_dict[value] = key
		...
		>>> new_dict
		{1: 'one', 2: 'two', 3: 'thee', 4: 'four'}

		#############################################
		>>> objects = ['blue', 'apple', 'dog']
		>>> categories = ['color', 'fruit', 'pet']
		>>> a_dict = {key: value for key, value in zip(categories, objects)}
		>>> a_dict
		{'color': 'blue', 'fruit': 'apple', 'pet': 'dog'}

		#############################################
		>>> a_dict = {'one': 1, 'two': 2, 'thee': 3, 'four': 4}
		>>> new_dict = {k: v for k, v in a_dict.items() if v <= 2}
		>>> new_dict
		{'one': 1, 'two': 2}

		#############################################

		>>> incomes = {'apple': 5600.00, 'orange': 3500.00, 'banana': 5000.00}
		>>> for key in sorted(incomes):
		...     print(key, '->', incomes[key])
		...
		apple -> 5600.0
		banana -> 5000.0
		orange -> 3500.0

		#############################################

		a_dict = {'color': 'blue', 'fruit': 'apple', 'pet': 'dog'}

		while True:
			try:
				print(f'Dictionary length: {len(a_dict)}')
				item = a_dict.popitem()
				print(f'{item} removed')
			except KeyError:
				print('The dictionary has no item now...')
				break

		o/p:
		>>> 
		================ RESTART: C:\Users\Abhay\OneDrive\Desktop\one.py ===============
		Dictionary length: 3
		('pet', 'dog') removed
		Dictionary length: 2
		('fruit', 'apple') removed
		Dictionary length: 1
		('color', 'blue') removed
		Dictionary length: 0
		The dictionary has no item now...
		>>> 
		#############################################
		>>> from collections import ChainMap
		>>> fruit_prices = {'apple': 0.40, 'orange': 0.35}
		>>> vegetable_prices = {'pepper': 0.20, 'onion': 0.55}
		>>> chained_dict = ChainMap(fruit_prices, vegetable_prices)
		>>> chained_dict  # A ChainMap object
		ChainMap({'apple': 0.4, 'orange': 0.35}, {'pepper': 0.2, 'onion': 0.55})
		>>> for key in chained_dict:
		...     print(key, '->', chained_dict[key])
		...
		pepper -> 0.2
		orange -> 0.35
		onion -> 0.55
		apple -> 0.4

		#############################################
		>>> fruit_prices = {'apple': 0.40, 'orange': 0.35}
		>>> vegetable_prices = {'pepper': 0.20, 'onion': 0.55}
		>>> # How to use the unpacking operator **
		>>> {**vegetable_prices, **fruit_prices}
		{'pepper': 0.2, 'onion': 0.55, 'apple': 0.4, 'orange': 0.35}
		>>> # You can use this feature to iterate through multiple dictionaries
		>>> for k, v in {**vegetable_prices, **fruit_prices}.items():
		...     print(k, '->', v)
		...
		pepper -> 0.2
		onion -> 0.55
		apple -> 0.4
		orange -> 0.35

		#############################################

11. Other Built-in methods

	abs()	Returns the absolute value of a number
	dir()	Returns a list of the specified object's properties and methods
	int()	Returns an integer number
	isinstance()	Returns True if a specified object is an instance of a specified object
	sum()	Sums the items of an iterator
	super()	Returns an object that represents the parent class
	type()	method returns class type of the argument(object) passed as parameter. type() function is mostly used for debugging purposes.
	zip()	Returns an iterator, from two or more iterators
	set()	Returns a new set object
	

a.
x = abs(-7.25)
print(x)

o/p:
>>> 
================ RESTART: C:\Users\Abhay\OneDrive\Desktop\one.py ===============
7.25
>>> 

b.
class Person:
  name = "John"
  age = 36
  country = "Norway"

print(dir(Person))

o/p:
>>> 
================ RESTART: C:\Users\Abhay\OneDrive\Desktop\one.py ===============
['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'age', 'country', 'name']
>>> 

c.
x = int(-3.5)
print(x)

x = int(4.5)
print(x)

o/p:

>>> 
================ RESTART: C:\Users\Abhay\OneDrive\Desktop\one.py ===============
-3
4
>>> 

d.

mystr = 'Hello World'
num = 100
flt = 10.2

print(isinstance(mystr, str)) # True
print(isinstance(mystr, int)) # False

print(isinstance(num, int))  # True
print(isinstance(num, str))  # False

print(isinstance(flt, float)) # True
print(isinstance(flt, int))   # False

##############################################

class student:
    name = 'Elon'

std = student()

print(isinstance(std, student))
print(isinstance(std, (student, list, str))) # tuple with class names
print(isinstance(std, list))

##############################################

cities = ['Mumbai','Chicago','New York']

print(isinstance(cities,list)) 
print(isinstance(cities,(tuple, set))) 
print(isinstance(cities,tuple)) 

##############################################

e.

numbers = [1,2,3,4,5,1,4,5]
total = sum(numbers)
print(total)
total = sum(numbers, 10)
print(total)

o/p:

>>> 
================ RESTART: C:\Users\Abhay\OneDrive\Desktop\one.py ===============
25
35
>>> 

##############################################
nums_set = {1, 2, 3, 4, 5}
total = sum(nums_set)
print("Total of set = ", total)

nums_tuple = (1, 2, 3, 4, 5)
total = sum(nums_tuple)
print("Total of tuple = ", total)

nums_dict = {1:'one',2:'two',3:'three'}
total = sum(nums_dict)
print("Total of dict Keys = ", total)

o/p:

>>> 
================ RESTART: C:\Users\Abhay\OneDrive\Desktop\one.py ===============
Total of set =  15
Total of tuple =  15
Total of dict Keys =  6
>>> 

##############################################

f.

#1 The super() builtin returns a proxy object (temporary object of the superclass)
that allows us to access methods of the base class.

#2 In Python, super() has two major use cases:

Allows us to avoid using the base class name explicitly
Working with Multiple Inheritance

#3
class Mammal(object):
  def __init__(self, mammalName):
    print(mammalName, 'is a warm-blooded animal.')
    
class Dog(Mammal):
  def __init__(self):
    print('Dog has four legs.')
    super().__init__('Dog')
    
d1 = Dog()

o/p:

>>> 
================ RESTART: C:\Users\Abhay\OneDrive\Desktop\one.py ===============
Dog has four legs.
Dog is a warm-blooded animal.
>>> 

Since we do not need to specify the name of the base class when we call its members,
we can easily change the base class name (if we need to).


####

class Animal:
  def __init__(self, Animal):
    print(Animal, 'is an animal.');

class Mammal(Animal):
  def __init__(self, mammalName):
    print(mammalName, 'is a warm-blooded animal.')
    super().__init__(mammalName)
    
class NonWingedMammal(Mammal):
  def __init__(self, NonWingedMammal):
    print(NonWingedMammal, "can't fly.")
    super().__init__(NonWingedMammal)

class NonMarineMammal(Mammal):
  def __init__(self, NonMarineMammal):
    print(NonMarineMammal, "can't swim.")
    super().__init__(NonMarineMammal)

class Dog(NonMarineMammal, NonWingedMammal):
  def __init__(self):
    print('Dog has 4 legs.');
    super().__init__('Dog')
    
d = Dog()
print('')
bat = NonMarineMammal('Bat')

#  o/p:

#  >>> 
#  =============== RESTART: C:\Users\Abhay\OneDrive\Desktop\rough.py ==============
#  Dog has 4 legs.
#  Dog can't swim.
#  Dog can't fly.
#  Dog is a warm-blooded animal.
#  Dog is an animal.

#  Bat can't swim.
#  Bat is a warm-blooded animal.
#  Bat is an animal.
#  >>> 

>>> Dog.__mro__
(<class 'Dog'>, 
<class 'NonMarineMammal'>, 
<class 'NonWingedMammal'>, 
<class 'Mammal'>, 
<class 'Animal'>, 
<class 'object'>)

##
Here is how Method Resolution Order(MRO) works:

A method in the derived calls is always called before the method of the base class.
In our example, Dog class is called before NonMarineMammal or NoneWingedMammal.
These two classes are called before Mammal, which is called before Animal, and Animal
class is called before the object.
If there are multiple parents like Dog(NonMarineMammal, NonWingedMammal), methods of
NonMarineMammal is invoked first because it appears first.

g.
print(type([]) is list)
print(type([]) is not list)
print(type(()) is tuple)
print(type({}) is dict)
print(type({}) is not list)

>>> 
================ RESTART: C:\Users\Abhay\OneDrive\Desktop\one.py ===============
True
False
True
True
True
>>> 

##
lang = 'Python'
nums = [1,2,3,4]
nums_dict = {'one':1,'two':2,'three':3}

print(type(nums))
print(type(lang))
print(type(nums_dict))

o/p:
>>> 
================ RESTART: C:\Users\Abhay\OneDrive\Desktop\one.py ===============
<class 'list'>
<class 'str'>
<class 'dict'>
>>> 

##
std = type('student', (object,), dict(name='John', age=12))
print(std.name)
print(std.age)

o/p:
>>> 
================ RESTART: C:\Users\Abhay\OneDrive\Desktop\one.py ===============
John
12
>>> 

##
class Foo:
    a = 0

foo = Foo()
print(type(foo))

o/p:
>>> 
================ RESTART: C:\Users\Abhay\OneDrive\Desktop\one.py ===============
<class '__main__.Foo'>
>>> 

h.

fields = ['name', 'last_name', 'age', 'job']
values = ['John', 'Doe', '45', 'Python Developer']

a_dict = dict(zip(fields, values))
print(a_dict)

o/p:
>>> 
================ RESTART: C:\Users\Abhay\OneDrive\Desktop\one.py ===============
{'name': 'John', 'last_name': 'Doe', 'age': '45', 'job': 'Python Developer'}
>>> 

i.

A = {1, 2, 3, 4, 5}
B = {4, 5, 6, 7, 8}

print(A - B)

o/p:
>>> 
=============== RESTART: C:\Users\Abhay\OneDrive\Desktop\rough.py ==============
{1, 2, 3}
>>> 

#####################################################################################################
#
#                     https://www.python-course.eu/python3_pytest.php
#
#####################################################################################################

1. A variable is a way of referring to a memory location used by a computer program. In many
programming languages a variable is a symbolic name for this physical location. This memory
location contains values, like numbers, text or more complicated types. We can use this
variable to tell the computer to save some data in this location or to retrieve some data from
this location.

2. i = 42
The equal "=" sign in the assignment shouldn't be seen as "is equal to". It should be "read" or
interpreted as "is set to", meaning in our example "the variable i is set to 42".

3. Python variables are references to objects, but the actual data is contained in the objects:

4. I am a python variable.My name is x and I can point to an arbitrary object.
In this case to an int object.
x = 42

5. As variables are pointing to objects and objects can be of arbitrary data type, variables cannot
have types associated with them.This is a huge difference to C, C++ or Java, where a variable
is associated with a fixed data type. This association can't be changed as long as the program is
running.
Therefore it is possible to write code like the following in Python:
>>> x = 42
>>> print(x)

6. We want to demonstrate something else now. Let's look at the following code:
>>> x = 42
>>> y = x
We created an integer object 42 and assigned it to the variable x. After this we assigned x to the
variable y. This means that both variables reference the same object.

x ---> 42 (an obect)   <---- y

7. y = 78
Python will create a new integer object with the content 78 and then the variable y will
reference this newly created object

8. How can we see or prove that x and y really reference the same object
The identity function id() can be used for this purpose. Every instance (object or variable) has
an identity, i.e., an integer which is unique within the script or program, i.e., other objects have
different identities.

9. 
>>> x = 42
>>> id(x)
10107136
>>> y = x
>>> id(x), id(y)
(10107136, 10107136)
>>> y = 78
>>> id(x), id(y)
(10107136, 10108288)
>>>

10. PYTHON KEYWORDS
No identifier can have the same name as one of the Python keywords, although they are
obeying the above naming conventions:

11. and, as, assert, break, class, continue, def, del, elif, else,
except, False, finally, for, from, global, if, import, in, is,
lambda, None, nonlocal, not, or, pass, raise, return, True, try,
while, with, yield
There is no need to learn them by heart. You can get the list of Python keywords in the
interactive shell by using help. You type help() in the interactive, but please don't forget the
parenthesis:
>>> help()

12. The Style Guide for Python Code recommends underscore notation for variable names as well as
function names.

13. "All identifiers in the Python standard library MUST use ASCII-only identifiers, and SHOULD
use English words wherever feasible (in many cases, abbreviations and technical terms are
used which aren't English). In addition, string literals and comments must also be in ASCII.
The only exceptions are (a) test cases testing the non-ASCII features, and (b) names of authors.
Authors whose names are not based on the latin alphabet MUST provide a latin transliteration
of their names

14. In other words, "//" always truncates towards negative infinity.

>>> 9 // 3
3
>>> 10 // 3
3
>>> 11 // 3
3
>>> 12 // 3
4
>>> 10.0 // 3
3.0
>>> -7 // 3
-3
>>> -7.0 // 3
-3.0
>>>

15. In other words, the meaning of a character or a written or printed text doesn't depend
on the font or writing style used. On a computer the capital A is encoded in binary form. If we
use ASCII it is encoded - like all the other characters - as the byte 65.

16. Characters consist of graphical shapes, so-called graphemes, consisting of lines, curves and
crossings in certain angles or positions.

17. UNICODE ENCODINGS
UTF-32,  UTF-16, UTF-8.

18. All strings in Python 3 are sequences of "pure" Unicode characters, no specific
encoding like UTF-8.

19. There are different ways to define strings in Python:
>>> s = 'I am a string enclosed in single quotes.'
>>> s2 = "I am another string, but I am enclosed in
double quotes"
Both s and s2 of the previous example are variables referencing string objects. We can see that
string literals can either be enclosed in matching single (') or in double quotes ("). Single quotes
will have to be escaped with a backslash (\), if the string is defined with single quotes:
>>> s3 = 'It doesn\'t matter!'
This is not necessary, if the string is represented by double quotes:
>>> s3 = "It doesn't matter!"
Analogously, we will have to escape a double quote inside a double quoted string:
>>> txt = "He said: \"It doesn't matter, if you enclose
a string in single or double quotes!\""
>>> print(txt)
He said: "It doesn't matter, if you enclose a string in
single or double quotes!"
>>>

20. SOME OPERATORS AND FUNCTIONS FOR STRINGS
Concatenation
Strings can be glued together (concatenated) with the + operator:
"Hello" + "World" will result in "HelloWorld"
Repetition
String can be repeated or repeatedly concatenated with the asterisk operator "*":
"*-*" * 3 will result in "*-**-**-*"
Indexing
"Python"[0] will result in "P"
Slicing
Substrings can be created with the slice or slicing notation, i.e., two indices in square
brackets separated by a colon:
"Python"[2:4] will result in "th"
Size
len("Python") will result in 6

21. IMMUTABLE STRINGS

Python strings cannot be changed. Trying to change an indexed position will raise an error:
>>> s = "Some things are immutable!"
>>> s[-1] = "."
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
TypeError: 'str' object does not support item
assignment
>>>
Beginners in Python are often confused, when they see the following codelines:
>>> txt = "He lives in Berlin!"
>>> txt = "He lives in Hamburg!"
The variable "txt" is a reference to a string object. We define a completely new string object in
the second assignment. So, you shouldn't confuse the variable name with the referenced object!

22. >>> a = "Linux"
>>> b = "Linux"
>>> a is b
True

23. >>> a = "Baden-Württemberg"
>>> b = "Baden-Württemberg"
>>> a is b
False
>>> a == b
True
You are right, it has nothing to do with geographical places. The special character, i.e., the
hyphen, is to "blame".
>>> a = "Baden!"
>>> b = "Baden!"
>>> a is b
False
>>> a = "Baden1"
>>> b = "Baden1"
>>> a is b
True

24. String literals may optionally be prefixed with a letter 'r' or 'R'; these strings are called raw strings.

25. Every string or text in Python 3 is Unicode, but encoded Unicode is represented as binary data.

26. While a string object holds a sequence of characters (in Unicode), a bytes object holds a
sequence of bytes, out of the range 0 .. 255, representing the ASCII values.
Defining bytes objects and casting them into strings:
>>> x = b"Hallo"
>>> t = str(x)
>>> u = t.encode("UTF-8")

############################################################################################################
27. LIST

(a) s.append(x)
This method appends an element to the end of the list "s".
>>> lst = [3, 5, 7]
>>> lst.append(42)
>>> lst
[3, 5, 7, 42]
>>>

(b) It's import to understand that append returns "None". This means that it usually
doesn't make sense to reassign the return value:
>>> lst = [3, 5, 7]
>>> lst = lst.append(42)
>>> print(lst)
None
>>>

(c) s.pop(i)
'pop' returns the ith element of a list s. The element will be removed from the list
as well.
>>> cities = ["Hamburg", "Linz", "Salzburg",
"Vienna"]

>>> cities.pop(0)
'Hamburg'
>>> cities
['Linz', 'Salzburg', 'Vienna']
>>> cities.pop(1)
'Salzburg'
>>> cities
['Linz', 'Vienna']
>>>
The method 'pop' raises an IndexError exception if the list is empty or the index is
out of range.

(d) s.pop() is equivalent to s.pop(-1).

>>> cities = ["Amsterdam", "The Hague",
"Strasbourg"]
>>> cities.pop()
'Strasbourg'
>>> cities
['Amsterdam', 'The Hague']
>>>

(e)
Python provides the method 'extend'. It extends a list by appending all
the elements of an iterable like a list, a tuple or a string to a list:
>>> lst = [42,98,77]
>>> lst2 = [8,69]
>>> lst.extend(lst2)
>>> lst
[42, 98, 77, 8, 69]
>>>

(f)

>>> lst = ["a", "b", "c"]
>>> programming_language = "Python"
>>> lst.extend(programming_language)
>>> print(lst)
['a', 'b', 'c', 'P', 'y', 't', 'h', 'o', 'n']

(g)

>>> lst = ["Java", "C", "PHP"]
>>> t = ("C#", "Jython", "Python", "IronPython")
>>> lst.extend(t)
>>> lst
['Java', 'C', 'PHP', 'C#', 'Jython', 'Python',
'IronPython']
>>>

(h)
EXTENDING AND APPENDING LISTS WITH THE '+'-OPERATOR

There is an alternative to 'append' and 'extend'. '+' can be used to combine lists.
>>> level = ["beginner", "intermediate",
"advanced"]
>>> other_words = ["novice", "expert"]
>>> level + other_words
['beginner', 'intermediate', 'advanced', 'novice',
'expert']
>>>

(i)
Be careful. Never ever do the following:
>>> L = [3, 4]
>>> L = L + [42]
>>> L
[3, 4, 42]
>>>
Even though we get the same result, it is not an alternative to 'append' and 'extend':
>>> L = [3, 4]
>>> L.append(42)
>>> L
[3, 4, 42]
>>>
>>>
>>> L = [3, 4]
>>> L.extend([42])
>>> L
[3, 4, 42]
>>>

(j) We will compare in the following example the different approaches and calculate their
run times. To understand the following program, you need to know that time.time()
returns a float number, the time in seconds since the so-called ,,The Epoch''1.
time.time() - start_time calculates the time in seconds consumed for the for loops:
import time
n= 100000
start_time = time.time()
l = []
for i in range(n):
l = l + [i * 2]
print(time.time() - start_time)
start_time = time.time()
l = []
for i in range(n):
l += [i * 2]
print(time.time() - start_time)
start_time = time.time()
l = []
for i in range(n):
l.append(i * 2)
print(time.time() - start_time)
This program returns shocking results:
10/31/2019 Python Tutorial: A Tutorial
https://www.python-course.eu/python3_list_manipulation.php 7/10
26.3175041676
0.0305399894714
0.0207479000092
We can see that the "+" operator is about 1268 slower than the append method. The
explanation is easy: If we use the append method, we will simply append a further
element to the list in each loop pass. Now we come to the first loop, in which we use l
= l + [i * 2]. The list will be copied in every loop pass. The new element will be
added to the copy of the list and result will be reassigned to the variable l. After this the
old list will have to be removed by Python, because it is not referenced anymore. We
can also see that the version with the augmented assignment ("+="), the loop in the
middle, is only slightly slower than the version using "append".

(k) REMOVING AN ELEMENT WITH REMOVE
It is possible to remove with the method "remove" a certain value from a list without
knowing the position.
s.remove(x)

(l) This call will remove the first occurrence of x from the list s. If x is not contained in the
list, a ValueError will be raised.

(m) FIND THE POSITION OF AN ELEMENT IN A LIST
>>> colours = ["red", "green", "blue", "green",
"yellow"]
>>> colours.index("green")
1
>>> colours.index("green", 2)
3
>>> colours.index("green", 3,4)
3
>>> colours.index("black")
Traceback (most recent call last):
File "", line 1, in
ValueError: 'black' is not in list
>>>

(n) INSERT
An object "object" will be included in the list "s". "object" will be placed before the
element s[index]. s[index] will be "object" and all the other elements will be moved one
to the right.
>>> lst = ["German is spoken", "in Germany,",
"Austria", "Switzerland"]
>>> lst.insert(3, "and")
>>> lst
['German is spoken', 'in Germany,', 'Austria',
'and', 'Switzerland']
>>>

28. Sets
They are used for example to get rid of doublets -
multiple occurrences of elements - in a list, i.e.
to make a list unique.

29. To cut out all the words of the novel "Ulysses" we can use the function findall from the
module "re":
import re
# we don't care about case sensitivity and
therefore use lower:
ulysses_txt =
open("books/james_joyce_ulysses.txt").read().lower()
words = re.findall(r"\b[\w-]+\b", ulysses_txt)
print("The novel ulysses contains " +
str(len(words)))
The novel ulysses contains 272452

30. This number is the sum of all the words and many words occur multiple time:
for word in ["the", "while", "good", "bad",
"ireland", "irish"]:
print("The word '" + word + "' occurs " + \
str(words.count(word)) + " times in the
novel!" )
The word 'the' occurs 15112 times in the novel!
The word 'while' occurs 123 times in the novel!
The word 'good' occurs 321 times in the novel!
The word 'bad' occurs 90 times in the novel!
The word 'ireland' occurs 90 times in the novel!
The word 'irish' occurs 117 times in the novel!

31. what is the difference between an iterable and an iterator ?

(a) You can iterate with a for loop over iterators and
iterables. Every iterator is also an iterable, but not every iterable is an iterator. E.g. a list
is iterable but a list is not an iterator! An iterator can be created from an iterable by
using the function 'iter'. To make this possible the class of an object needs either a
method '__iter__', which returns an iterator, or a '__getitem__' method with sequential
indexes starting with 0.

(b) Iterators are objects with a '__next__' method, which will be used when the function
'next' is called.

(c) So what is going on behind the scenes, when a for loop is executed? The for statement
calls iter() on the object ( which should be a so-called container object), which it is
supposed to loop over. If this call is successful, the iter call will return return an iterator
object that defines the method __next__() which accesses elements of the object one at
a time. The __next__() method will raise a StopIteration exception, if there are no
further elements available. The for loop whill terminate as soon as it catches a
StopIteration exception. You can call the __next__() method using the next() built-in
function. This is how it works:

cities = ["Berlin", "Vienna", "Zurich"]
iterator_obj = iter(cities)
print(iterator_obj)
print(next(iterator_obj))
print(next(iterator_obj))
print(next(iterator_obj))
<list_iterator object at 0x7f08a055e0b8>
Berlin
Vienna
Zurich

(d) So if you want to add an iterator behavior to
your class, you have to add the __iter__ and the __next__ method to your class. The
__iter__ method returns an iterator object. If the class contains a __next__, it is enough
for the __iter__ method to return self, i.e. a reference to itself:
class Reverse:
"""
Creates Iterators for looping over a sequence
backwards.
"""
def __init__(self, data):
self.data = data
self.index = len(data)
def __iter__(self):
return self
def __next__(self):
if self.index == 0:
raise StopIteration
self.index = self.index - 1
return self.data[self.index]
lst = [34, 978, 42]
lst_backwards = Reverse(lst)
for el in lst_backwards:
print(el)
42
978
34

32. CLASS ATTRIBUTES

a. Instance attributes are owned by the specific instances of a class.
b. Class attributes are attributes which are owned by the class itself.
   They will be shared by all the instances of the
class. Therefore they have the same value for every instance. We define class attributes
outside of all the methods, usually they are placed at the top, right below the class
header.

33. Besides this, we see that we can
access a class attribute via an instance or via the class name:

>>> class A:
	a = 5

	
>>> x = A()
>>> y = A()
>>> x.a
5
>>> y.a
5
>>> A.a
5
>>> x.a = 100
>>> x.a
100
>>> y.a
5
>>> A.a
5
>>> A.a = 999
>>> x.a
100
>>> y.a
999
>>> A.a
999
>>> x.__dict__
{'a': 100}
>>> y.__dict__
{}
>>> A.__dict__
mappingproxy({'__module__': '__main__', 'a': 999, '__dict__': <attribute '__dict__' of 'A' objects>, '__weakref__': <attribute '__weakref__' of 'A' objects>, '__doc__': None})
>>> 

34. 
how you can count instance with class
attributes. All we have to do is
to create a class attribute, which we call "counter" in our example
to increment this attribute by 1 every time a new instance will be create
to decrement the attribute by 1 every time an instance will be destroyed
class C:
counter = 0
def __init__(self):
type(self).counter += 1
def __del__(self):
type(self).counter -= 1
if __name__ == "__main__":
x = C()
print("Number of instances: : " +
str(C.counter))
y = C()
print("Number of instances: : " +
str(C.counter))
del x
print("Number of instances: : " +
str(C.counter))
del y

print("Number of instances: : " +
str(C.counter))

Principially, we could have written C.counter instead of type(self).counter, because
type(self) will be evaluated to "C" anyway. But we will see later, that type(self) makes
sense, if we use such a class as a superclass.

35. STATIC METHODS

(a) Of course, we can
make public attributes private as well. We can do this by adding the double underscore
again. If we do so, we need a possibility to access and change these private class
attributes.

class Robot:
counter = 0
def __init__(self):
type(self).__counter += 1
@staticmethod
def RobotInstances():
return Robot.__counter
if __name__ == "__main__":
print(Robot.RobotInstances())
x = Robot()
print(x.RobotInstances())
y = Robot()
print(x.RobotInstances())
print(Robot.RobotInstances())
We will get the following output:
0
1
2
2

36. CLASS METHODS

(a) Like static methods class
methods are not bound to instances, but unlike static methods class methods are bound
to a class.

(b) class Robot:
__counter = 0
def __init__(self):
type(self).__counter += 1
@classmethod
def RobotInstances(cls):
return cls, Robot.__counter
if __name__ == "__main__":
print(Robot.RobotInstances())
x = Robot()
print(x.RobotInstances())
y = Robot()
print(x.RobotInstances())
print(Robot.RobotInstances())
The output looks like this:
$ python3 static_methods4.py
<class '__main__.Robot'>, 0)
<class '__main__.Robot'>, 1)
<class '__main__.Robot'>, 2)
<class '__main__.Robot'>, 2)
The use cases of class methods:
the are used in the definition of the so-called factory methods, which we will not
cover here.
They are often used, where we have static methods, which have to call other static
methods. To do this, we would have to hard code the class name, if we had to use
static methods. This is a problem, if we are in a use case, where we have inherited
classes.

(c)
class fraction(object):
def __init__(self, n, d):
self.numerator, self.denominator =
fraction.reduce(n, d)
@staticmethod
def gcd(a,b):
while b != 0:
a, b = b, a%b
return a
@classmethod
def reduce(cls, n1, n2):
g = cls.gcd(n1, n2)
return (n1 // g, n2 // g)
def __str__(self):
return
str(self.numerator)+'/'+str(self.denominator)

Using this class:
>>> from fraction1 import fraction
>>> x = fraction(8,24)
>>> print(x)
1/3
>>>

37. TRUE OR FALSE

The following objects are evaluated by Python as False:

numerical zero values (0, 0.0, 0.0+0.0j),
the Boolean value False,
empty strings,
empty lists and empty tuples,
empty dictionaries.
plus the special value None.
All other values are considered to be True.

38. lst = [3,4]
list.__dict__["append"](lst, 42)
lst
The previous Python code returned the following output:
[3, 4, 42]

39. items in dictionaries are accessed via keys and not via their position.

40. What happens, if we try to access a key, i.e. a city, which is not contained in the
dictionary? We raise a KeyError:

41. de_fr = {"rot" : "rouge", "grün" : "vert", "blau"
: "bleu", "gelb":"jaune"}
print("The French word for red is: " +
de_fr[en_de["red"]])
The output of the previous script:
{'blue': 'blau', 'green': 'grün', 'yellow':
'gelb', 'red': 'rot'}
rot
The French word for red is: rouge

42. We can use arbitrary types as values in a dictionary, but there is a restriction for the
keys. Only immutable data types can be used as keys, i.e. no lists or dictionaries can be
used:
If you use a mutable data type as a key, you get an error message:
>>> dic = { [1,2,3]:"abc"}
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
TypeError: list objects are unhashable

Tuple as keys are okay, as you can see in the following example:
>>> dic = { (1,2,3):"abc", 3.1415:"abc"}
>>> dic
{3.1415: 'abc', (1, 2, 3): 'abc'}

43. OPERATORS ON DICTIONARIES

Operator Explanation
len(d) returns the number of stored entries, i.e. the number of (key,value) pairs.
del d[k] deletes the key k together with his value
k in d True, if a key k exists in the dictionary d
k not in d True, if a key k doesn't exist in the dictionary d

44. If D is a dictionary, then D.pop(k) removes the key k with its value from the dictionary
D and returns the corresponding value as the return value, i.e. D[k].
If the key is not found a KeyError is raised:
>>> en_de = {"Austria":"Vienna",
"Switzerland":"Bern", "Germany":"Berlin",
"Netherlands":"Amsterdam"}
>>> capitals = {"Austria":"Vienna",
"Germany":"Berlin", "Netherlands":"Amsterdam"}
>>> capital = capitals.pop("Austria")
>>> print(capital)
Vienna
>>> print(capitals)
{'Netherlands': 'Amsterdam', 'Germany': 'Berlin'}
>>> capital = capitals.pop("Switzerland")
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
KeyError: 'Switzerland'
>>>
If we try to find out the capital of Switzerland in the previous example, we raise a
KeyError. To prevent these errors, there is an elegant way. The method pop() has an
optional second parameter, which can be used as a default value:
>>> capital = capitals.pop("Switzerland", "Bern")
>>> print(capital)
Bern
>>> capital = capitals.pop("France", "Paris")
>>> print(capital)
Paris
>>> capital = capitals.pop("Germany", "München")
>>> print(capital)
Berlin

>>> sample = {'a':1,'b':2,'c':3}
>>> sample
{'a': 1, 'b': 2, 'c': 3}
>>> output =sample.pop('a')
>>> output
1
>>> sample
{'b': 2, 'c': 3}
>>> sample.pop('b',2)
2
>>> sample
{'c': 3}
>>> 

45. >>> sample = {'a':1,'b':2,'c':3,'d':4}
>>> sample
{'a': 1, 'b': 2, 'c': 3, 'd': 4}
>>> sample.popitem()
('d', 4)
>>> sample
{'a': 1, 'b': 2, 'c': 3}
>>> sample.popitem()
('c', 3)
>>> sample
{'a': 1, 'b': 2}
>>> sample.popitem()
('b', 2)
>>> sample
{'a': 1}
>>> sample.popitem()
('a', 1)
>>> sample
{}
>>> sample.popitem()
Traceback (most recent call last):
  File "<pyshell#10>", line 1, in <module>
    sample.popitem()
KeyError: 'popitem(): dictionary is empty'
>>> 

46. get() method

>>> proj_language = {"proj1":"Python",
"proj2":"Perl", "proj3":"Java"}
>>> proj_language["proj1"]
'Python'
>>> proj_language["proj4"]
Traceback (most recent call last):
File "<stdin>", line 1, in
KeyError: 'proj4'
>>> proj_language.get("proj2")
'Perl'
>>> proj_language.get("proj4")
>>> print(proj_language.get("proj4"))
None
>>> # setting a default value:
>>> proj_language.get("proj4", "Python")
'Python'
>>>

47. A dictionary can be copied with the method copy():
>>> w = words.copy()
>>> words["cat"]="chat"
>>> print(w)
{'house': 'Haus', 'cat': 'Katze'}
>>> print(words)
{'house': 'Haus', 'cat': 'chat'}
This copy is a shallow and not a deep copy.

48. The content of a dictionary can be cleared with the method clear(). The dictionary is not
deleted, but set to an empty dictionary:
>>> w.clear()
>>> print(w)
{}

49. >>> knowledge = {"Frank": {"Perl"}, "Monica":
{"C","C++"}}
>>> knowledge2 = {"Guido":{"Python"}, "Frank":
{"Perl", "Python"}}
>>> knowledge.update(knowledge2)
>>> knowledge
{'Frank': {'Python', 'Perl'}, 'Guido': {'Python'},
'Monica': {'C', 'C++'}}

50. No method is needed to iterate over the keys of a dictionary:
>>> d = {"a":123, "b":34, "c":304, "d":99}
>>> for key in d:
... print(key)
...
b
c
a
d
>>>
But it's possible to use the method keys(), but we will get the same result:
>>> for key in d.keys():
... print(key)
...
b
c
a
d
>>>
The method values() is a convenient way for iterating directly over the values:
>>> for value in d.values():
... print(value)
...
34
304
123
99
>>>
The above loop is logically equivalent to the following one:

for key in d:
print(d[key])
We said logically, because the second way is less efficient!

51. >>> w = {"house":"Haus", "cat":"", "red":"rot"}
>>> items_view = w.items()
>>> items = list(items_view)
>>> items
[('house', 'Haus'), ('cat', ''), ('red', 'rot')]
>>>
>>> keys_view = w.keys()
>>> keys = list(keys_view)
>>> keys
['house', 'cat', 'red']
>>>
>>> values_view = w.values()
>>> values = list(values_view)
>>> values
['Haus', '', 'rot']
>>> values_view
dict_values(['Haus', '', 'rot'])
>>> items_view
dict_items([('house', 'Haus'), ('cat', ''),
('red', 'rot')])
>>> keys_view
dict_keys(['house', 'cat', 'red'])
>>>

52. TURN LISTS INTO DICTIONARIES

Now we will turn our attention to the art of cooking, but don't be afraid, this remains a
python course and not a cooking course. We want to show you, how to turn lists into
dictionaries, if these lists satisfy certain conditions.
We have two lists, one containing the dishes and the other one the corresponding
countries:

>>> dishes = ["pizza", "sauerkraut", "paella",
"hamburger"]
>>> countries = ["Italy", "Germany", "Spain",
"USA"]
Now we will create a dictionary, which assigns a dish, a country-specific dish, to a
country; please forgive us for resorting to the common prejudices. For this purpose we
need the function zip(). The name zip was well chosen, because the two lists get
combined like a zipper. The result is a list iterator. This means that we have to wrap a
list() casting function around the zip call to get a list so that we can see what is going
on:
>>> country_specialities_iterator = zip(countries,
dishes)
>>> country_specialities_iterator
<zip object at 0x7fa5f7cad408>
>>> country_specialities =
list(country_specialities_iterator)
>>> print(country_specialities)
[('Italy', 'pizza'), ('Germany', 'sauerkraut'),
('Spain', 'paella'), ('USA', 'hamburger')]
>>>
Now our country-specific dishes are in a list form, - i.e. a list of two-tuples, where the
first components are seen as keys and the second components as values - which can be
automatically turned into a dictionary by casting it with dict().
>>> country_specialities_dict =
dict(country_specialities)
>>> print(country_specialities_dict)
{'USA': 'hamburger', 'Germany': 'sauerkraut',
'Spain': 'paella', 'Italy': 'pizza'}
>>>
Yet, this is very inefficient, because we created a list of 2-tuples to turn this list into a
dict. This can be done directly by applying dict to zip:
10/31/2019 Python Tutorial: Dictionaries
https://www.python-course.eu/python3_dictionaries.php 20/23
>>> dishes = ["pizza", "sauerkraut", "paella",
"hamburger"]
>>> countries = ["Italy", "Germany", "Spain",
"USA"]
>>> dict(zip(countries, dishes))
{'USA': 'hamburger', 'Germany': 'sauerkraut',
'Spain': 'paella', 'Italy': 'pizza'}
>>>
There is still one question concerning the function zip(). What happens, if one of the
two argument lists contains more elements than the other one?
It's easy to answer: The superfluous elements, which cannot be paired, will be ignored:
>>> dishes = ["pizza", "sauerkraut", "paella",
"hamburger"]
>>> countries = ["Italy", "Germany", "Spain",
"USA"," Switzerland"]
>>> country_specialities = list(zip(countries,
dishes))
>>> country_specialities_dict =
dict(country_specialities)
>>> print(country_specialities_dict)
{'Germany': 'sauerkraut', 'Italy': 'pizza', 'USA':
'hamburger', 'Spain': 'paella'}
>>>
So in this course, we will not answer the burning question, what the national dish of
Switzerland is.
EVERYTHING IN ONE STEP
10/31/2019 Python Tutorial: Dictionaries
https://www.python-course.eu/python3_dictionaries.php 21/23
Normally, we recommend not to implement too many steps in one programming
expression, though it looks more impressive and the code is more compact. Using
"talking" variable names in intermediate steps can enhance legibility. Though it might
be alluring to create our previous dictionary just in one go:
>>> country_specialities_dict =
dict(list(zip(["pizza", "sauerkraut", "paella",
"hamburger"], ["Italy", "Germany", "Spain",
"USA"," Switzerland"])))
>>> print(country_specialities_dict)
{'paella': 'Spain', 'hamburger': 'USA',
'sauerkraut': 'Germany', 'pizza': 'Italy'}
>>>
On the other hand, the code in the previous script is gilding the lily:
dishes = ["pizza", "sauerkraut", "paella",
"hamburger"]
countries = ["Italy", "Germany", "Spain", "USA"]
country_specialities_zip = zip(dishes,countries)
print(list(country_specialities_zip))
country_specialities_list =
list(country_specialities_zip)
country_specialities_dict =
dict(country_specialities_list)
print(country_specialities_dict)
We get the same result, as if we would have called it in one go.

53. You have to keep in mind that iterators exhaust
themselves, if they are used. You can see this in the following interactive session:
>>> l1 = ["a","b","c"]
>>> l2 = [1,2,3]
>>> c = zip(l1, l2)
>>> for i in c:
... print(i)
...
('a', 1)
('b', 2)
('c', 3)
>>> for i in c:
... print(i)
...
This effect can be seen by calling the list casting operator as well:
>>> l1 = ["a","b","c"]
>>> l2 = [1,2,3]
>>> c = zip(l1,l2)
>>> z1 = list(c)
>>> z2 = list(c)
>>> print(z1)
[('a', 1), ('b', 2), ('c', 3)]
>>> print(z2)
[]
As an exercise, you may muse about the following script.
dishes = ["pizza", "sauerkraut", "paella",
"hamburger"]
countries = ["Italy", "Germany", "Spain", "USA"]
country_specialities_zip = zip(dishes,countries)
print(list(country_specialities_zip))
country_specialities_list =
list(country_specialities_zip)
country_specialities_dict =
dict(country_specialities_list)
print(country_specialities_dict)
If you start this script, you will see that the dictionary you want to create will be empty:
$ python3 tricky_code.py
[('pizza', 'Italy'), ('sauerkraut', 'Germany'),
('paella', 'Spain'), ('hamburger', 'USA')]
{}
$

############################################################################################################
54. that applying "type" to an object returns the class of
which the object is an instance of:

x = [4, 5, 9]
y = "Hello"
print(type(x), type(y))
The code above returned the following:
<class 'list'> <class 'str'>

55. If you apply type on the name of a class itself, you get the class "type" returned.
print(type(list), type(str))
The above Python code returned the following:
<class 'type'> <class 'type'>

56. This is similar to applying type on type(x) and type(y):
x = [4, 5, 9]
y = "Hello"
print(type(x), type(y))
print(type(type(x)), type(type(y)))
This gets us the following result:
<class 'list'> <class 'str'>
<class 'type'> <class 'type'>

57. A user-defined class (or the class "object") is an instance of the class "type". So, we can
see, that classes are created from type. In Python3 there is no difference between
"classes" and "types". They are in most cases used as synonyms.

58. The fact that classes are instances of a class "type" allows us to program metaclasses.
We can create classes, which inherit from the class "type". So, a metaclass is a subclass
of the class "type".

59. Instead of only one argument, type can be called with three parameters:
type(classname, superclasses, attributes_dict)
If type is called with three arguments, it will return a new type object. This provides us
with a dynamic form of the class statement.
(a) "classname" is a string defining the class name and becomes the name attribute;
(b) "superclasses" is a list or tuple with the superclasses of our class. This list or tuple
will become the bases attribute;
(c) the attributes_dict is a dictionary, functioning as the namespace of our class. It
contains the definitions for the class body and it becomes the dict attribute.

60. class A:
pass
x = A()
print(type(x))
After having executed the Python code above we received the following result:
<class '__main__.A'>
We can use "type" for the previous class defintion as well:
A = type("A", (), {})
x = A()
print(type(x))
The previous Python code returned the following result:
<class '__main__.A'>
Generally speaking, this means, that we can define a class A with
type(classname, superclasses, attributedict)
When we call "type", the call method of type is called. The call method runs two other
methods: new and init:
type.__new__(typeclass, classname, superclasses,
attributedict)
type.__init__(cls, classname, superclasses,
attributedict)

The new method creates and returns the new class object, and after this the init method
initializes the newly created object.

61. class Robot:
counter = 0
def __init__(self, name):
self.name = name
def sayHello(self):
return "Hi, I am " + self.name
def Rob_init(self, name):
self.name = name
Robot2 = type("Robot2",
(),
{"counter":0,
"__init__": Rob_init,
"sayHello": lambda self: "Hi, I am
" + self.name})
x = Robot2("Marvin")
print(x.name)
print(x.sayHello())
y = Robot("Marvin")
print(y.name)
print(y.sayHello())
print(x.__dict__)
print(y.__dict__)
The previous Python code returned the following result:
Marvin
Hi, I am Marvin
Marvin
Hi, I am Marvin
{'name': 'Marvin'}
{'name': 'Marvin'}

The class definitions for Robot and Robot2 are syntactically completely different, but
they implement logically the same class.

############################################################################################################
62. We have two different kinds of decorators in Python:
Function decorators
Class decorators

63. A decorator in Python is any callable
Python object that is used to modify a function or a class. A reference to a function
"func" or a class "C" is passed to a decorator and the decorator returns a modified
function or class. The modified functions or classes usually contain calls to the original
function "func" or class "C".

64. First you have to know or remember that function names are references to
functions and that we can assign multiple names to the same function:
>>> def succ(x):
... return x + 1
...
>>> successor = succ
>>> successor(10)
11
>>> succ(10)
11

65. This means that we have two names, i.e. "succ" and "successor" for the same function.
The next important fact is that we can delete either "succ" or "successor" without
deleting the function itself.
>>> del succ
>>> successor(10)
11

66. 
def our_decorator(func):
def function_wrapper(x):
print("Before calling " + func.__name__)
func(x)
print("After calling " + func.__name__)
return function_wrapper
@our_decorator
def foo(x):
print("Hi, foo has been called with " +
str(x))
foo("Hi")
We can decorate every other function which takes one parameter with our decorator
'our_decorator'. We demonstrate this in the following. We have slightly changed our
function wrapper, so that we can see the result of the function calls:
def our_decorator(func):
def function_wrapper(x):
print("Before calling " + func.__name__)
res = func(x)
print(res)
print("After calling " + func.__name__)
return function_wrapper
@our_decorator
def succ(n):
return n + 1
succ(10)
The output of the previous program:
Before calling succ
11
After calling succ

67. CHECKING ARGUMENTS WITH A DECORATOR

The following program uses a decorator function to ensure that the argument passed to
the function factorial is a positive integer:
def argument_test_natural_number(f):
def helper(x):
if type(x) == int and x > 0:
return f(x)
else:
raise Exception("Argument is not an
integer")
return helper
@argument_test_natural_number
def factorial(n):
if n == 1:
return 1
else:
return n * factorial(n-1)
for i in range(1,10):
print(i, factorial(i))
print(factorial(-1))

68. COUNTING FUNCTION CALLS WITH DECORATORS

def call_counter(func):
def helper(x):
helper.calls += 1
return func(x)
helper.calls = 0
return helper
@call_counter
def succ(x):
return x + 1
print(succ.calls)
for i in range(10):
succ(i)
print(succ.calls)

69. 
def call_counter(func):
def helper(*args, **kwargs):
helper.calls += 1
return func(*args, **kwargs)
helper.calls = 0
return helper
@call_counter
def succ(x):
return x + 1
@call_counter
def mul1(x, y=1):
return x*y + 1
print(succ.calls)
for i in range(10):
succ(i)
mul1(3, 4)
mul1(4)
mul1(y=3, x=2)
print(succ.calls)
print(mul1.calls)

The output looks like this:
0
10
3

70. 
def greeting(expr):
def greeting_decorator(func):
def function_wrapper(x):
print(expr + ", " + func.__name__ + "
returns:")
func(x)
return function_wrapper
return greeting_decorator
@greeting("καλημερα")
def foo(x):
print(42)
foo("Hi")
The output:
καλημερα, foo returns:
42
If we don't want or cannot use the "at" decorator syntax, we can do it with function
calls:
def greeting(expr):
def greeting_decorator(func):
def function_wrapper(x):
print(expr + ", " + func.__name__ + " returns:")
func(x)
return function_wrapper
return greeting_decorator
def foo(x):
print(42)
greeting2 = greeting("καλημερα")
foo = greeting2(foo)
foo("Hi")
The result is the same as before:
καλημερα, foo returns:
42
Of course, we don't need the additional definition of "greeting2". We can directly apply
the result of the call "greeting("καλημερα")" on "foo":
foo = greeting("καλημερα")(foo)

71. USING WRAPS FROM FUNCTOOLS

The way we have defined decorators so far hasn't taken into account that the attributes
__name__ (name of the function),
__doc__ (the docstring) and
__module__ (The module in which the function is defined)
of the original functions will be lost after the decoration.
The following decorator will be saved in a file greeting_decorator.py:

def greeting(func):
def function_wrapper(x):
""" function_wrapper of greeting """
print("Hi, " + func.__name__ + "
returns:")
return func(x)
return function_wrapper
We call it in the following program:
from greeting_decorator import greeting
@greeting
def f(x):
""" just some silly function """
return x + 4
f(10)
print("function name: " + f.__name__)
print("docstring: " + f.__doc__)
print("module name: " + f.__module__)
We get the following "unwanted" results:
Hi, f returns:
function name: function_wrapper
docstring: function_wrapper of greeting
module name: greeting_decorator

72. 
We can import the decorator "wraps" from functools instead and decorate our function
in the decorator with it:
from functools import wraps
def greeting(func):
@wraps(func)
def function_wrapper(x):
""" function_wrapper of greeting """
print("Hi, " + func.__name__ + "
returns:")
return func(x)
return function_wrapper

73. USING A CLASS AS A DECORATOR

class decorator2:
def __init__(self, f):
self.f = f
def __call__(self):
print("Decorating", self.f.__name__)
self.f()
@decorator2
def foo():
print("inside foo()")
foo()

Both versions return the same output:
Decorating foo
inside foo()

############################################################################################################
LIST COMPREHENSION

74. List comprehension is a complete substitute for the lambda function as well as the
functions map(), filter() and reduce().List comprehension is an elegant way to define and create list in Python.

75. convert Celsius values into Fahrenheit and vice versa.
>>> Celsius = [39.2, 36.5, 37.3, 37.8]
>>> Fahrenheit = [ ((float(9)/5)*x + 32) for x in
Celsius ]
>>> print(Fahrenheit)
[102.56, 97.700000000000003, 99.140000000000001,
100.03999999999999]
>>>

76.
The following list comprehension creates the Pythagorean triples:
>>> [(x,y,z) for x in range(1,30) for y in
range(x,30) for z in range(y,30) if x**2 + y**2 ==
z**2]
[(3, 4, 5), (5, 12, 13), (6, 8, 10), (7, 24, 25),
(8, 15, 17), (9, 12, 15), (10, 24, 26), (12, 16,
20),(15, 20, 25), (20, 21, 29)]

77.
>>> colours = [ "red", "green", "yellow", "blue" ]
>>> things = [ "house", "car", "tree" ]
>>> coloured_things = [ (x,y) for x in colours for
y in things ]
>>> print(coloured_things)
[('red', 'house'), ('red', 'car'), ('red',
'tree'), ('green', 'house'), ('green', 'car'),
('green', 'tree'), ('yellow', 'house'), ('yellow',
'car'), ('yellow', 'tree'), ('blue', 'house'),
('blue', 'car'), ('blue', 'tree')]
>>>

78. GENERATOR COMPREHENSION

a generator comprehension returns a generator instead of a list.
>>> x = (x **2 for x in range(20))
>>> print(x)
at 0xb7307aa4>
>>> x = list(x)
>>> print(x)
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121,
144, 169, 196, 225, 256, 289, 324, 361]

79. SET COMPREHENSION

>>> from math import sqrt
>>> n = 100
>>> sqrt_n = int(sqrt(n))
>>> no_primes = {j for i in range(2, sqrt_n+1) for
j in range(i*2, n, i)}
>>> no_primes
{4, 6, 8, 9, 10, 12, 14, 15, 16, 18, 20, 21, 22,
24, 25, 26, 27, 28, 30, 32, 33, 34, 35, 36, 38,
39, 40, 42, 44, 45, 46, 48, 49, 50, 51, 52, 54,
55, 56, 57, 58, 60, 62, 63, 64, 65, 66, 68, 69,
70, 72, 74, 75, 76, 77, 78, 80, 81, 82, 84, 85,
86, 87, 88, 90, 91, 92, 93, 94, 95, 96, 98, 99}
>>> primes = {i for i in range(2, n) if i not in
no_primes}
>>> print(primes)
{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41,
43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97}
>>>

80. RECURSIVE FUNCTION TO CALCULATE THE PRIMES

The following Python script uses a recursive function to calculate the prime numbers. It
incorporates the fact that it is enough to examine the multiples of the prime numbers up
to the square root of n:
from math import sqrt
def primes(n):
if n == 0:
return []
elif n == 1:
return []
else:
p = primes(int(sqrt(n)))
no_p = {j for i in p for j in range(i*2,
n+1, i)}
p = {x for x in range(2, n + 1) if x not
in no_p}
return p
for i in range(1,50):
print(i, primes(i))

############################################################################################################
REGULAR EXPRESSIONS

81. [a-e] a simplified writing for [abcde] or [0-5] denotes [012345]

82. Exercise:
What character class is described by [-a-z]?
Answer The character "-" and all the characters "a", "b", "c" all the way up to "z".

83. The only other special character inside square brackets (character class choice) is the
caret "^". If it is used directly after an opening sqare bracket, it negates the choice. [^0-
9] denotes the choice "any character but a digit". The position of the caret within the
square brackets is crucial. If it is not positioned as the first character following the
opening square bracket, it has no special meaning.
[^abc] means anything but an "a", "b" or "c"
[a^bc] means an "a", "b", "c" or a "^"

84. 
M1
---
import re
fh = open("simpsons_phone_book.txt")
for line in fh:
if re.search(r"J.*Neu",line):
print(line.rstrip())
fh.close()
The program above returns the following results:
Jack Neu 555-7666
Jeb Neu 555-5543
Jennifer Neu 555-3652

M2
---
Instead of downloading simpsons_phone_book.txt, we can use the file directly from the
website by using urlopen from the module urllib.request:
import re
from urllib.request import urlopen
with urlopen('https://www.pythoncourse.
eu/simpsons_phone_book.txt') as fh:
for line in fh:
# line is a byte string so we transform it
to utf-8:
line = line.decode('utf-8').rstrip()
if re.search(r"J.*Neu",line):
print(line)

85. PREDEFINED CHARACTER CLASSES
\d Matches any decimal digit; equivalent to the set [0-9].
\D The complement of \d. It matches any non-digit character; equivalent to the set
[^0-9].
\s Matches any whitespace character; equivalent to [ \t\n\r\f\v].
\S The complement of \s. It matches any non-whitespace character; equiv. to [^
\t\n\r\f\v].
\w
Matches any alphanumeric character; equivalent to [a-zA-Z0-9_]. With LOCALE,
it will match the set [a-zA-Z0-9_] plus characters defined as letters for the current
locale.
\W Matches the complement of \w.
\b Matches the empty string, but only at the start or end of a word.
\B Matches the empty string, but not at the start or end of a word.
\\ Matches a literal backslash.

86. >>> import re
>>> s1 = "Mayer is a very common Name"
>>> s2 = "He is called Meyer but he isn't German."
>>> print(re.search(r"^M[ae][iy]er", s1))
<_sre.SRE_Match object at 0x7fc59c5f26b0>
>>> print(re.search(r"^M[ae][iy]er", s2))
None
But what happens if we concatenate the two strings s1 and s2 in the following way:
s = s2 + "\n" + s1
Now the string doesn't start with a Maier of any kind, but the name is following a
newline character:
>>> s = s2 + "\n" + s1
>>> print(re.search(r"^M[ae][iy]er", s))
None
>>>

87.
>>> print(re.search(r"^M[ae][iy]er", s,
re.MULTILINE))
<_sre.SRE_Match object at 0x7fc59c5f26b0>
>>> print(re.search(r"^M[ae][iy]er", s, re.M))
<_sre.SRE_Match object at 0x7fc59c5f26b0>
>>> print(re.match(r"^M[ae][iy]er", s, re.M))
None
>>>
The previous example also shows that the multiline mode doesn't affect the match
method. match() never checks anything but the beginning of the string for a match.

88.
>>> print(re.search(r"Python\.$","I like
Python."))
<_sre.SRE_Match object at 0x7fc59c5f26b0>
>>> print(re.search(r"Python\.$","I like Python
and Perl."))
None
>>> print(re.search(r"Python\.$","I like
Python.\nSome prefer Java or Perl."))
None
>>> print(re.search(r"Python\.$","I like
Python.\nSome prefer Java or Perl.", re.M))
<_sre.SRE_Match object at 0x7fc59c5f26b0>
>>>

89.
If we try to figure out a fitting regular expression, we realize that we miss something. A
way to tell the computer "this "e" may or may not occur". A question mark is used as a
notation for this. A question mark declares that the preceding character or expression is
optional.
The final Mayer-Recognizer looks now like this:
r"M[ae][iy]e?r"
A subexpression is grouped by round brackets and a question mark following such a
group means that this group may or may not exist. With the following expression we
can match dates like "Feb 2011" or February 2011":
r"Feb(ruary)? 2011"

90. QUANTIFIERS

A quantifier after a token, which can be a single character or group in brackets,
specifies how often that preceding element is allowed to occur. The most common
quantifiers are
the question mark ?
the asterisk or star character *, which is derived from the Kleene star
and the plus sign +, derived from the Kleene cross

91.
Exercise:
Write a regular expression which matches strings which starts with a sequence of digits
- at least one digit - followed by a blank.
Solution:
r"^[0-9][0-9]* "

92.
A star following a character or a subexpression group means that this
expression or character may be repeated arbitrarily, even zero times.
r"[0-9]*"

93. 
Using + or * are too unspecific for our purpose and the following expression seems to
be too clumsy:
r"^[0-9][0-9][0-9][0-9] [A-Za-z]+"
Fortunately, there is an alternative available:
r"^[0-9]{4} [A-Za-z]*"

94. 
r"^[0-9]{4,5} [A-Z][a-z]{2,}"
The general syntax is {from, to}: this means that the expression has to appear at least
"from" times and not more than "to" times. {, to} is an abbreviated spelling for {0,to}
and {from,} is an abbreviation for "at least from times but no upper limit"

95. A match object contains the methods group(), span(), start() and end(), as can be seen in
the following application:

>>> import re
>>> mo = re.search("[0-9]+", "Customer number:
232454, Date: February 12, 2011")
>>> mo.group()
'232454'
>>> mo.span()
(17, 23)
>>> mo.start()
17

96.
>>> mo.end()
23
>>> mo.span()[0]
17
>>> mo.span()[1]
23
>>>
These methods are not difficult to understand. span() returns a tuple with the start and
end position, i.e. the string index where the regular expression started matching in the
string and ended matching. The methods start() and end() are in a way superfluous as
the information is contained in span(), i.e. span()[0] is equal to start() and span()[1] is
equal to end(). group(), if called without argument, returns the substring, which had
been matched by the complete regular expression. With the help of group() we are also
capable of accessing the matched substring by grouping parentheses, to get the matched
substring of the n-th group, we call group() with the argument n: group(n).
We can also call group with more than integer argument, e.g. group(n,m). group(n,m) -
provided there exists a subgoup n and m - returns a tuple with the matched substrings.
group(n,m) is equal to (group(n), group(m)):

>>> import re
>>> mo = re.search("([0-9]+).*: (.*)", "Customer
number: 232454, Date: February 12, 2011")
>>> mo.group()
'232454, Date: February 12, 2011'
>>> mo.group(1)
'232454'
>>> mo.group(2)
'February 12, 2011'
>>> mo.group(1,2)
('232454', 'February 12, 2011')
>>>

97. A very intuitive example are XML or HTML tags. E.g. let's assume we have a file
(called "tags.txt") with content like this:
<composer>Wolfgang Amadeus Mozart</composer>
<author>Samuel Beckett</author>
<city>London</city>
We want to rewrite this text automatically to
composer: Wolfgang Amadeus Mozart
author: Samuel Beckett
city: London

import re
fh = open("tags.txt")
for i in fh:
res = re.search(r"<([a-z]+)>(.*)</\1>",i)
print(res.group(1) + ": " + res.group(2))

98.
import re
l = ["555-8396 Neu, Allison",
"Burns, C. Montgomery",
"555-5299 Putz, Lionel",
"555-7334 Simpson, Homer Jay"]
for i in l:
res = re.search(r"([0-9-]*)\s*([A-Za-z]+),\s+
(.*)", i)
print(res.group(3) + " " + res.group(2) + " "
+ res.group(1))

output -
Allison Neu 555-8396
C. Montgomery Burns
Lionel Putz 555-5299
Homer Jay Simpson 555-7334

99.
Using capturing groups instead of "numbered" capturing groups allows you to assign
descriptive names instead of automatic numbers to the groups. In the following
example, we demonstrate this approach by catching the hours, minutes and seconds
from a UNIX date string.
>>> import re
>>> s = "Sun Oct 14 13:47:03 CEST 2012"
>>> expr = r"\b(?P<hours>\d\d):(?P<minutes>\d\d):
(?P<seconds>\d\d)\b"
>>> x = re.search(expr,s)
>>> x.group('hours')
'13'
>>> x.group('minutes')
'47'
>>> x.start('minutes')
14
>>> x.end('minutes')
16
>>> x.span('seconds')
(17, 19)
>>>

100.COMPREHENSIVE PYTHON EXERCISE

In this comprehensive exercise, we have to bring together the information of two files.
In the first file, we have a list of nearly 15000 lines of post codes with the
corresponding city names plus additional information. Here are some arbitrary lines of
this file:
osm_id ort plz bundesland
1104550 Aach 78267 Baden-Württemberg
...
446465 Freiburg (Elbe) 21729 Niedersachsen
62768 Freiburg im Breisgau 79098 Baden-Württemberg
62768 Freiburg im Breisgau 79100 Baden-Württemberg
62768 Freiburg im Breisgau 79102 Baden-Württemberg
...
454863 Fulda 36037 Hessen
454863 Fulda 36039 Hessen
454863 Fulda 36041 Hessen
...
1451600 Gallin 19258 Mecklenburg-Vorpommern
449887 Gallin-Kuppentin 19386 Mecklenburg-
Vorpommern
10/31/2019 Python Tutorial: Regular Expression
https://www.python-course.eu/python3_re.php 23/27
...
57082 Gärtringen 71116 Baden-Württemberg
1334113 Gartz (Oder) 16307 Brandenburg
...
2791802 Giengen an der Brenz 89522 Baden-
Württemberg
2791802 Giengen an der Brenz 89537 Baden-
Württemberg
...
1187159 Saarbrücken 66133 Saarland
1256034 Saarburg 54439 Rheinland-Pfalz
1184570 Saarlouis 66740 Saarland
1184566 Saarwellingen 66793 Saarland
The other file contains a list of the 19 largest German cities. Each line consists of the
rank, the name of the city, the population, and the state (Bundesland):
1. Berlin 3.382.169 Berlin
2. Hamburg 1.715.392 Hamburg
3. München 1.210.223 Bayern
4. Köln 962.884 Nordrhein-Westfalen
5. Frankfurt am Main 646.550 Hessen
6. Essen 595.243 Nordrhein-Westfalen
7. Dortmund 588.994 Nordrhein-Westfalen
8. Stuttgart 583.874 Baden-Württemberg
9. Düsseldorf 569.364 Nordrhein-Westfalen
10. Bremen 539.403 Bremen
11. Hannover 515.001 Niedersachsen
12. Duisburg 514.915 Nordrhein-Westfalen
13. Leipzig 493.208 Sachsen
14. Nürnberg 488.400 Bayern
15. Dresden 477.807 Sachsen
16. Bochum 391.147 Nordrhein-Westfalen
17. Wuppertal 366.434 Nordrhein-Westfalen
10/31/2019 Python Tutorial: Regular Expression
https://www.python-course.eu/python3_re.php 24/27
18. Bielefeld 321.758 Nordrhein-Westfalen
19. Mannheim 306.729 Baden-Württemberg
Our task is to create a list with the top 19 cities, with the city names accompanied by
the postal code. If you want to test the following program, you have to save the list
above in a file called largest_cities_germany.txt and you have to download and save the
list of German post codes
import re
with open("zuordnung_plz_ort.txt", encoding="utf-
8") as fh_post_codes:
codes4city = {}
for line in fh_post_codes:
res = re.search(r"[\d ]+([^\d]+[az])\
s(\d+)", line)
if res:
city, post_code = res.groups()
if city in codes4city:
codes4city[city].add(post_code)
else:
codes4city[city] = {post_code}
with open("largest_cities_germany.txt",
encoding="utf-8") as fh_largest_cities:
for line in fh_largest_cities:
re_obj = re.search(r"^[0-9]{1,2}\.\s+
([\w\s-]+\w)\s+[0-9]", line)
city = re_obj.group(1)
print(city, codes4city[city])
The output of this file looks like this, but we have left out all but the first three postal
codes for every city:
Berlin {'10715', '13158', '13187', ...}
Hamburg {'22143', '22119', '22523', ...}
München {'80802', '80331', '80807', ...}
Köln {'51065', '50997', '51067', ...}
Frankfurt am Main {'65934', '60529', '60308', ...}
Essen {'45144', '45134', '45309', ... }
Dortmund {'44328', '44263', '44369',...}
Stuttgart {'70174', '70565', '70173', ...}
Düsseldorf {'40217', '40589', '40472', ...}
Bremen {'28207', '28717', '28777', ...}
Hannover {'30169', '30419', '30451', ...}
Duisburg {'47137', '47059', '47228', ...}
Leipzig {'4158', '4329', '4349', ...'}
Nürnberg {'90419', '90451', '90482', ...}
Dresden {'1217', '1169', '1324', ...}
Bochum {'44801', '44892', '44805', ...}
Wuppertal {'42109', '42119', '42287', ...}
Bielefeld {'33613', '33607', '33699', ...}
Mannheim {'68161', '68169', '68167', ...}

101. ANOTHER COMPREHENSIVE EXAMPLE

A regular expression for matching this superset of UK postcodes looks like this:
r"\b[A-Z]{1,2}[0-9R][0-9A-Z]? [0-9][ABD-HJLNP-UWZ]{
2}\b"
The following Python program uses the regexp above:
import re
example_codes = ["SW1A 0AA", # House of Commons
"SW1A 1AA", # Buckingham Palace
"SW1A 2AA", # Downing Street
"BX3 2BB", # Barclays Bank
"DH98 1BT", # British Telecom
"N1 9GU", # Guardian Newspaper
"E98 1TT", # The Times
"TIM E22", # a fake postcode
"A B1 A22", # not a valid
postcode
"EC2N 2DB", # Deutsche Bank
"SE9 2UG", # University of
Greenwhich
"N1 0UY", # Islington, London
"EC1V 8DS", # Clerkenwell, London
"WC1X 9DT", # WC1X 9DT
"B42 1LG", # Birmingham
"B28 9AD", # Birmingham
"W12 7RJ", # London, BBC News
Centre
"BBC 007" # a fake postcode
]

pc_re = r"[A-z]{1,2}[0-9R][0-9A-Z]? [0-9][ABDHJLNP-
UW-Z]{2}"
for postcode in example_codes:
r = re.search(pc_re, postcode)
if r:
print(postcode + " matched!")
else:
print(postcode + " is not a valid
postcode!")

############################################################################################################

PYTEST

102. Test files which pytest will use for testing have to start with test_ or end with
_test.py

103. 
The first file is the file which should be tested. We assume that it is saved as
fibonacci.py:
def fib(n):
old, new = 0, 1
for _ in range(n):
old, new = new, old + new
return old
Now, we have to provide the code for the file test_fibonacci.py. This file will be used by 'pytest':
from fibonacci import fib
def test_fib():
assert fib(0) == 0
assert fib(1) == 1
assert fib(10) == 55
We call pytest in a command shell in the directory where the two file shown above reside:
(base) bernd@moon:~$ pytest
The result of this code can be seen in the following:
============================= test session starts
==============================
platform linux -- Python 3.7.1, pytest-4.0.2, py-1.7.0, pluggy-0.8.0
rootdir: /home/bernd/Dropbox
(Bodenseo)/kurse/python_en/examples/pytest/pytest_ex1, inifile:
plugins: remotedata-0.3.1, openfiles-0.3.1, doctestplus-0.2.0, arraydiff-0.3
collected 1 item
test_fibonacci.py .
[100%]
=========================== 1 passed in 0.01 seconds
===========================

104.
(a) The files to be tested:
	fibonacci.py
	foobar_plus.py
	foobar.py
	The test files:
	test_fibonacci.py

	The test files:
	test_fibonacci.py
	test_foobar_plus.py
	test_foobar.py
	We start 'pytest' in the directory 'ex2' and get the following results:
	$ pytest
	==================== test session starts ======================
	platform linux -- Python 3.7.3, pytest-4.3.1, py-1.8.0, pluggy-0.9.0
	rootdir: /home/bernd/Dropbox (Bodenseo)/websites/pythoncourse.
	eu/examples/pytest/ex2, inifile:
	plugins: remotedata-

 (b) We will select now only the files containing 'plus' and 'fibo'
 	 $ pytest -k 'plus or fibo'
	 ============================= test session starts
	 ==============================
	 platform linux -- Python 3.7.1, pytest-4.0.2, py-1.7.0, pluggy-0.8.0
	 rootdir:

105. MARKERS IN PYTEST

     Test functions can be marked or tagged by decorating them with 'pytest.mark.'.
     Such a marker can be used to select or deselect test functions.
	 You can see the markers which exist for your test suite by typing
	 $ pytest --markers
	 @pytest.mark.openfiles_ignore:
	 @pytest.mark.remote_data:
	 @pytest.mark.internet_off:
	 @pytest.mark.filterwarnings(warning):
	 @pytest.mark.skip(reason=None):
	 @pytest.mark.skipif(condition):
	 @pytest.mark.xfail(condition, reason=None, run=True, raises=None, strict=False):
     @pytest.mark.parametrize(argnames, argvalues):
	 @pytest.mark.usefixtures(fixturename1, fixturename2, ...):
	 @pytest.mark.tryfirst:
	 @pytest.mark.trylast:
	 Above list also contains custom defined markers!
	 
106. REGISTERING MARKERS

	Since pytest version 4.5 markers have to be registered.
	They can be registered in the init file pytest.ini, placed in the test directory.
	We register the markers 'slow' and 'crazy', which we will use in the following example:
	[pytest]
	markers =
	slow: mark a test as a 'slow' (slowly) running test
	crazy: stupid function to test :-)
	We add a recursive and inefficient version rfib to our fibonacci module and mark the corresponding test routine with slow, besides
	this rfib is marked with crazy as well:
	# content of fibonacci.py
	def fib(n):
	old, new = 0, 1
	for i in range(n):	 
	old, new = new, old + new
	return old
	def rfib(n):
	if n == 0:
	return 0
	elif n == 1:
	return 1
	else:
	return rfib(n-1) + rfib(n-2)
	The corresponding test file:
	#content of test_fibonacci.py
	import pytest
	from fibonacci import fib, rfib
	def test_fib():
	assert fib(0) == 0
	assert fib(1) == 1
	assert fib(34) == 5702887
	@pytest.mark.crazy
	@pytest.mark.slow
	def test_rfib():
	assert fib(0) == 0
	assert fib(1) == 1
	assert rfib(34) == 5702887
	Besides this we will add the files foobar.py and test_foobar.py as well. We mark the test functions in test_foobar.py as crazy.
	# content of foobar.py
	def foo():
	return "foo"
	def bar():
	return "bar"
	This is the correponding test file:
	# content of test_foobar.py
	import pytest
	from foobar import foo, bar
	@pytest.mark.crazy
	def test_foo():
	assert foo() == "foo"
	@pytest.mark.crazy
	def test_bar():
	assert bar() == "bar"
	We will start tests now depending on the markers.
	Let's start all tests, which are not marked as slow:
	$ pytest -svv -k "slow"
	===================================== test session starts
	======================================
	platform linux -- Python 3.7.1, pytest-4.0.2, py-1.7.0, pluggy-0.8.0 --
	/home/bernd/anaconda3/bin/python
	cachedir: .pytest_cache
	rootdir: /home/bernd/Dropbox
	(Bodenseo)/kurse/python_en/examples/pytest/ex_tagging, inifile:
	plugins: remotedata-0.3.1, openfiles-0.3.1, doctestplus-0.2.0, arraydiff-0.3
	collected 4 items / 3 deselected
	test_fibonacci.py::test_rfib PASSED
	============================ 1 passed, 3 deselected in 7.05 seconds
	============================
	We will run now only the tests which are not marked as slow or crazy:
	$ pytest -svv -k "not slow and not crazy"
	======================= test session starts =======================
	platform linux -- Python 3.7.1, pytest-4.0.2, py-1.7.0, pluggy-0.8.0 --
	/home/bernd/anaconda3/bin/python
	cachedir: .pytest_cache
	rootdir: /home/bernd/Dropbox
	(Bodenseo)/kurse/python_en/examples/pytest/ex_tagging, inifile:
	plugins: remotedata-0.3.1, openfiles-0.3.1, doctestplus-0.2.0, arraydiff-0.3
	collected 4 items / 3 deselected
	test_fibonacci.py::test_fib PASSED
	===================== 1 passed, 3 deselected in 0.01 seconds
	====================
	 
107. SKIPIF MARKER

	(a)
	
	import pytest
	import sys
	from foobar import foo, bar
	@pytest.mark.skipif(
	sys.version_info[0] == 3 and sys.version_info[1] == 6,
	reason="Python version has to be higher than 3.5!")
	def test_foo():
	assert foo() == "foo"
	@pytest.mark.crazy
	def test_bar():
	assert bar() == "bar"	 

	(b) 
	
	Instead of a conditional skip we can also use an uncoditional skip. This way we can always skip. We can add a reason. The
	following example shows how this can be accomplished by marking the function test_bar with a skip marker. The reason we give is
	that it is "even fooer than foo":
	import pytest
	import sys
	from foobar import foo, bar
	@pytest.mark.skipif(
	sys.version_info[0] == 3 and sys.version_info[1] == 6,
	reason="Python version has to be higher than 3.5!")
	def test_foo():
	assert foo() == "foo"
	@pytest.mark.skip(reason="Even fooer than foo, so we skip!")
	def test_bar():
	assert bar() == "bar"

	If we call pytest on this code, we get the following output:
	$ pytest -v
	================ test session starts ===============
	platform linux -- Python 3.6.9, pytest-5.0.1, py-1.8.0, pluggy-0.12.0 --
	/home/bernd/anaconda3/envs/unittest/bin/python
	cachedir: .pytest_cache
	rootdir: /home/bernd/Dropbox
	(Bodenseo)/kurse/python_en/examples/pytest/ex_tagging2, inifile: pytest.ini
	collected 4 items

108. PARAMETRIZATION WITH MARKERS

	We will demonstrate parametrization with markers with our Fibonacci function.
	# content of fibonacci.py
	def fib(n):
	old, new = 0, 1
	for _ in range(n):
	old, new = new, old + new
	return old
	We write a pytest test function which will test against this fibonacci function with various values:
	# content of the file test_fibonacci.py
	import pytest
	from fibonacci import fib
	@pytest.mark.parametrize(
	'n, res', [(0, 0),
	(1, 1),
	(2, 1),
	(3, 2),
	(4, 3),
	(5, 5),
	(6, 8)])
	def test_fib(n, res):
	assert fib(n) == res
	
	When we call pytest, we get the following results:
	$ pytest -v
	============================ test session starts ============================
	platform linux -- Python 3.6.9, pytest-5.0.1, py-1.8.0, pluggy-0.12.0 --
	/home/bernd/anaconda3/envs/unittest/bin/python
	cachedir: .pytest_cache
	rootdir: /home/bernd/Dropbox
	(Bodenseo)/kurse/python_en/examples/pytest/ex_parametrization1
	collected 7 items
	test_fibonacci.py::test_fib[0-0] PASSED
	[ 14%]
	test_fibonacci.py::test_fib[1-1] PASSED
	[ 28%]
	test_fibonacci.py::test_fib[2-1] PASSED
	[ 42%]
	test_fibonacci.py::test_fib[3-2] PASSED
	[ 57%]
	test_fibonacci.py::test_fib[4-3] PASSED
	[ 71%]
	test_fibonacci.py::test_fib[5-5] PASSED
	[ 85%]
	test_fibonacci.py::test_fib[6-8] PASSED
	[100%]
	https://www.python-course.eu/python3_pytest.php 10/12
	========================== 7 passed in 0.01 seconds =========================
	The numbers inside of the square brackets on front of the word "PASSED" are the values of 'n' and 'res'.

109. Calling "pytest -s -v" will deliver the following output:

110. COMMAND LINE OPTIONS / FIXTURES

	At first, we have to write a file conftest.py with the functions cmdopt and pytest_addoption:
	 
	import pytest
	def pytest_addoption(parser):
	parser.addoption("--cmdopt",
	action="store",
	default="full",
	help="'num' of tests or full")
	@pytest.fixture
	def cmdopt(request):
	return request.config.getoption("--cmdopt")
	The code for our fibonacci test module looks like. The test_fif function has a parameter 'cmdopt' which gets the parameter option:
	from fibonacci import fib
	results = [0, 1, 1, 2, 3, 5, 8, 13, 21,
	34, 55, 89, 144, 233, 377]
	def test_fib(cmdopt):
	if cmdopt == "full":
	num = len(results)
	else:
	num = len(results)
	if int(cmdopt) < len(results):
	num = int(cmdopt)
	for i in range(num):
	assert fib(i) == results[i]
	We can call it now with various options, as we can see in the following:
	$ pytest -q --cmdopt=full -v -s
	============ test session starts ================
	platform linux -- Python 3.6.9, pytest-5.0.1, py-1.8.0, pluggy-0.12.0
	rootdir: /home/bernd/Dropbox
	(Bodenseo)/kurse/python_en/examples/pytest/ex_cmd_line
	collected 1 item
	test_fibonacci.py running 15 tests!
	.
	============= 1 passed in 0.01 seconds ============
	$ pytest -q --cmdopt=6 -v -s
	============= test session starts ==============
	platform linux -- Python 3.6.9, pytest-5.0.1, py-1.8.0, pluggy-0.12.0
	rootdir: /home/bernd/Dropbox
	(Bodenseo)/kurse/python_en/examples/pytest/ex_cmd_line
	collected 1 item
	 
	test_fibonacci.py running 6 tests!
	.
	=========================== 1 passed in 0.01 seconds
	================================
	Let's put an error in our test results:
	results = [0, 1, 1, 2, 3, 1001, 8,…]
	Calling pytest with 'pytest -q --cmdopt=10 -v -s' gives us the following output:
	================== test session starts ================== platform linux -- Python 3.6.9, pytest-5.0.1, py-1.8.0, pluggy-
	0.12.0 rootdir: /home/bernd/Dropbox (Bodenseo)/kurse/python_en/examples/pytest/ex_cmd_line collected 1 item test_fibonacci.py
	running 10 tests! F =============== FAILURES =================== _______________test_fib
	___________________ cmdopt = '10' def test_fib(cmdopt): if cmdopt == "full": num = len(results) else: num = len(results) if
	int(cmdopt) < len(results): num = int(cmdopt) print(f"running {num:2d} tests!") for i in range(num): > assert fib(i) == results[i] E
	assert 5 == 1001 E + where 5 = fib(5) test_fibonacci.py:16: AssertionError ================ 1 failed in 0.03 seconds
	=================	 
	 
111. 
112. 
############################################################################################################

OPERATOR OVERLOADING

1. Operator Overloading means giving extended meaning beyond their predefined operational meaning.

############################################################################################################
2.
# Python program to show use of
# + operator for different purposes.
print(1 + 2)
# concatenate two strings
print("Geeks"+"For")
# Product two numbers
print(3 * 4)
# Repeat the String
print("Geeks"*4)

Output:
3
GeeksFor
12
GeeksGeeksGeeksGeeks

############################################################################################################
3. when we use + operator, the magic method __add__ is automatically invoked in which the operation for
+ operator is defined.

4. 
# Python Program illustrate how 
# to overload an binary + operator 

class A: 
	def __init__(self, a): 
		self.a = a 

	# adding two objects 
	def __add__(self, o): 
		return self.a + o.a 
ob1 = A(1) 
ob2 = A(2) 
ob3 = A("Geeks") 
ob4 = A("For") 

print(ob1 + ob2) 
print(ob3 + ob4) 

Output :

3
GeeksFor

5. 
# Python program to overload 
# a comparison operators 

class A: 
	def __init__(self, a): 
		self.a = a 
	def __gt__(self, other): 
		if(self.a>other.a): 
			return True
		else: 
			return False
ob1 = A(2) 
ob2 = A(3) 
if(ob1>ob2): 
	print("ob1 is greater than ob2") 
else: 
	print("ob2 is greater than ob1") 

6.
Python magic methods or special functions for operator overloading
Binary Operators:
OPERATOR	MAGIC METHOD
+	__add__(self, other)
–	__sub__(self, other)
*	__mul__(self, other)
/	__truediv__(self, other)
//	__floordiv__(self, other)
%	__mod__(self, other)
**	__pow__(self, other)

Comparison Operators :
OPERATOR	MAGIC METHOD
<	__lt__(self, other)
>	__gt__(self, other)
<=	__le__(self, other)
>=	__ge__(self, other)
==	__eq__(self, other)
!=	__ne__(self, other)

Assignment Operators :
OPERATOR	MAGIC METHOD
-=	__isub__(self, other)
+=	__iadd__(self, other)
*=	__imul__(self, other)
/=	__idiv__(self, other)
//=	__ifloordiv__(self, other)
%=	__imod__(self, other)
**=	__ipow__(self, other)

Unary Operators :
OPERATOR	MAGIC METHOD
–	__neg__(self, other)
+	__pos__(self, other)
~	__invert__(self, other)

############################################################################################################
EXCEPTIONAL HANDLING

124.
Let's look at a simple example. Assuming we want to ask the user to enter an integer
number. If we use a input(), the input will be a string, which we have to cast into an
integer. If the input has not been a valid integer, we will generate (raise) a ValueError.
We show this in the following interactive session:
>>> n = int(input("Please enter a number: "))
Please enter a number: 23.5
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
ValueError: invalid literal for int() with base
10: '23.5'
With the aid of exception handling, we can write robust code for reading an integer
from input:
while True:
try:
n = input("Please enter an integer: ")
n = int(n)
break
except ValueError:
print("No valid integer! Please try again
...")
print("Great, you successfully entered an
integer!")

125. A try statement may have more than one except clause for different exceptions. But at
most one except clause will be executed.

126. 
import sys
try:
f = open('integers.txt')
s = f.readline()
i = int(s.strip())
except IOError as e:
errno, strerror = e.args
print("I/O error({0}):
{1}".format(errno,strerror))
# e can be printed directly without using
.args:
# print(e)
except ValueError:
print("No valid integer in line.")
except:
print("Unexpected error:", sys.exc_info()[0])
raise

The except
clause for the IOError specifies a variable "e" after the exception name (IOError). The
variable "e" is bound to an exception instance with the arguments stored in
instance.args.
If we call the above script with a non-existing file, we get the message:
I/O error(2): No such file or directory
And if the file integers.txt is not readable, e.g. if we don't have the permission to read it,
we get the following message:
I/O error(13): Permission denied

127.
An except clause may name more than one exception in a tuple of error names, as we
see in the following example:
try:
f = open('integers.txt')
s = f.readline()
i = int(s.strip())
except (IOError, ValueError):
print("An I/O error or a ValueError occurred")
except:
print("An unexpected error occurred")
raise

128. CUSTOM-MADE EXCEPTIONS

class MyException(Exception):
pass
raise MyException("An exception doesn't always
prove the rule!")

129. ELSE CLAUSE

The try ... except statement has an optional else clause. An else block has to be
positioned after all the except clauses. An else clause will be executed if the try clause
doesn't raise an exception.

python exception_test.py integers.txt

import sys
file_name = sys.argv[1]
text = []
try:
fh = open(file_name, 'r')
except IOError:
print('cannot open', file_name)
else:
text = fh.readlines()
fh.close()
if text:
print(text[100])

############################################################################################################
EXECUTE A PYTHON SCRIPT

130. The truth is: Python is both an interpreted and a compiled language.

131. People would assume that the compiler
translates the Python code into machine language. Python code is translated into
intermediate code, which has to be executed by a virtual machine, known as the PVM,
the Python virtual machine.

132. For whatever reason you want to compile a python program manually? No problem. It
can be done with the module py_compile, either using the interpreter shell

>>> import py_compile
>>>
py_compile.compile('my_first_simple_program.py')
>>>
or using the following command at the shell prompt
python -m py_compile my_first_simple_program.py
Either way, you may notice two things: First, there will be a new subdirectory
"__pycache__", if it hasn't already existed. You will find a file
"my_first_simple_script.cpython-34.pyc" in this subdirectory. This is the compiled
version of our file in byte code.

133. You can also automatically compile all Python files using the compileall module.

monty@python:~/python$ python -m compileall .
Listing . ...

134. Some newbies to Python wonder sometimes where these ominous files with the .pyc suffix might come
from. If Python has write-access for the directory where the Python program resides, it
will store the compiled byte code in a file that ends with a .pyc suffix. If Python has no
write access, the program will work anyway. The byte code will be produced but
discarded when the program exits.

135. Whenever a Python program is called, Python will check, if a compiled version with the
.pyc suffix exists. This file has to be newer than the file with the .py suffix. If such a file
exists, Python will load the byte code, which will speed up the start up time of the
script. If there exists no byte code version, Python will create the byte code before it
starts the execution of the program. Execution of a Python program means execution of
the byte code on the Python Virtual Machine (PVM).

Source code ---> Byte code ---> Python Virtual Machine

136. RUNNABLE SCRIPTS UNDER LINUX

A Python script can also be started like any other script under Linux, e.g. Bash scripts.
Two steps are necessary for this purpose:

1. The shebang line #!/usr/bin/env python3 has to be added as the first line of your
Python code file. Alternatively, this line can be #!/usr/bin/python3, if this is the
location of your Python interpreter. By instead using env as in the first shebang
line, the interpreter is searched for and located at the time the script is run. This
makes the script more portable. Yet, it also suffers from the same problem: The
path to env may also be different on a per-machine basis.

2. The file has to be made executable: The command "chmod +x scriptname" has to
be executed on a Linux shell, e.g. bash. "chmod 755 scriptname" can also be used
to make your file executable. In our example:
$ chmod +x my_first_simple_program.py

############################################################################################################

FILE MANAGEMENT

137. The "r" is optional. An open() command with just a file name is opened for reading per
default. The open() function returns a file object, which offers attributes and methods.
fobj = open("ad_lesbiam.txt")

138. 
fobj = open("ad_lesbiam.txt")
for line in fobj:
	print(line.rstrip())

fobj.close()

139. You will often find the with statement for reading and writing files. The advantage is
that the file will be automatically closed after the indented block after the with has
finished execution:

with open("example.txt", "w") as fh:
	fh.write("To write or not to write\nthat is
	the question!\n")

140.
>>> poem = open("ad_lesbiam.txt").readlines()
>>> print(poem)
['V. ad Lesbiam \n', '\n', 'VIVAMUS mea Lesbia,
atque amemus,\n', 'rumoresque senum severiorum\n',
'omnes unius aestimemus assis!\n', 'soles occidere
et redire possunt:\n', 'nobis cum semel occidit
breuis lux,\n', 'nox est perpetua una
dormienda.\n', 'da mi basia mille, deinde
centum,\n', 'dein mille altera, dein secunda
centum,\n', 'deinde usque altera mille, deinde
centum.\n', 'dein, cum milia multa fecerimus,\n',
'conturbabimus illa, ne sciamus,\n', 'aut ne quis
malus inuidere possit,\n', 'cum tantum sciat esse
basiorum.\n', '(GAIUS VALERIUS CATULLUS)']
>>> print(poem[2])
VIVAMUS mea Lesbia, atque amemus,

141.
Another convenient way to read in a file might be the method read() of open. With this
method we can read the complete file into a string, as we can see in the next example:
>>> poem = open("ad_lesbiam.txt").read()
>>> print(poem[16:34])
VIVAMUS mea Lesbia
>>> type(poem)
<type 'str'>
>>>

142. To work with seek, we will often need the method tell,
which "tells" us the current position.When we have just opened a file, it will be zero.

143.
>>> fh = open("buck_mulligan.txt")
>>> fh.tell()
0
>>> fh.read(7)
'Stately'
>>> fh.tell()
7
>>> fh.read()
', plump Buck Mulligan came from the stairhead,
bearing a bowl of\nlather on which a mirror and a
razor lay crossed.\n'
>>> fh.tell()
122
>>> fh.seek(9)
9
>>> fh.read(5)
'plump'




############################################################################################################
FUNCTIONS

144. Using functions usually enhances the comprehensibility and quality of the program. It also lowers the
cost for development and maintenance of the software.

145. If the return statement is without an expression, the special value None is returned.

146. If there is no return statement in the function code, the function ends, when the control flow reaches
the end of the function body and the value "None" will be returned.

147. The first statement in the body of a function is usually a string, which can be accessed
with function_name.__doc__
This statement is called Docstring.
Example:
def Hello(name="everybody"):
""" Greets a person """
print("Hello " + name + "!")
print("The docstring of the function Hello: " +
Hello.__doc__)
The output:
The docstring of the function Hello: Greets a
person

148. KEYWORD PARAMETERS

def sumsub(a, b, c=0, d=0):
return a - b + c - d
print(sumsub(12,4))
print(sumsub(42,15,d=10))

Keyword parameters can only be those, which are not used as positional arguments. We
can see the benefit in the example. If we hadn't keyword parameters, the second call to
function would have needed all four arguments, even though the c needs just the default
value:
print(sumsub(42,15,0,10))

149. A function can return exactly one value, or we should better say one object.

150. Variable names are by default local to the function, in which they get defined.

def f():
print(s)
s =
"Python"
f()
Output:
Python

def f():
s =
"Perl"
print(s)
Output:
Perl
Python

151.
s =
"Python"
f()
print(s)
def f():
print(s)
s =
"Perl"
print(s)
s =
"Python"
f()
print(s)
If we execute the previous script, we get the
error message:
UnboundLocalError: local variable 's'
referenced before assignment
The variable s is ambigious in f(), i.e. in the
first print in f() the global s could be used
with the value "Python". After this we define
a local variable s with the assignment s =
"Perl"
def f():
global s
print(s)
s =
"dog"
print(s)
s = "cat"
f()
print(s)

152. ARBITRARY NUMBER OF PARAMETERS

def arithmetic_mean(first, *values):
""" This function calculates the arithmetic
mean of a non-empty
arbitrary number of numerical values """
return (first + sum(values)) / (1 +
len(values))

x = [3, 5, 9]
arithmetic_mean(*x)
You cannot call it with arithmetic_mean(x) because "arithmetic_mean" can't cope with a list.

153. ARBITRARY NUMBER OF KEYWORD PARAMETERS

>>> def f(a,b,x,y):
... print(a,b,x,y)
…
>>> d = {'a':'append',
'b':'block','x':'extract','y':'yes'}
>>> f(**d)
('append', 'block', 'extract', 'yes')

############################################################################################################
GLOBAL, LOCAL AND NON LOCAL VARIABLES

154. Global variables are generally bad practice and should be avoided.

155. When you define variables inside a function definition, they are local to this function
by default. This means that anything you will do to such a variable in the body of the
function will have no effect on other variables outside of the function, even if they have
the same name. This means that the function body is the scope of such a variable, i.e.
the enclosing context where this name with its values is associated.

156. All variables have the scope of the block, where they are declared and defined in. They
can only be used after the point of their declaration.

157. 
def f():
s = "I love London!"
print(s)
s = "I love Paris!"
f()
print(s)
The output looks like this:
I love London!
I love Paris!

158. Ambiguous situation.
A variable can't be both local and global inside of a function.

>>> def f():
... print(s)
... s = "I love London!"
... print(s)
...
>>> s = "I love Paris!"
>>> f()
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
File "<stdin>", line 2, in f
UnboundLocalError: local variable 's' referenced
before assignment
>>>

159.
def f():
global s
print(s)
s = "Only in spring, but London is great as
well!"
print(s)
s = "I am looking for a course in Paris!"
f()
print(s)

OUTPUT:
I am looking for a course in Paris!
Only in spring, but London is great as well!
Only in spring, but London is great as well!

160.
Local variables of functions can't be accessed from outside, when the function call has
finished:
def f():
s = "I am globally not known"
print(s)
f()
print(s) --> NameError: name 's' is not defined

161.
def foo(x, y):
global a
a = 42
x,y = y,x
b = 33
b = 17
c = 100
print(a,b,x,y)
a, b, x, y = 1, 15, 3,4
foo(17, 4)
print(a, b, x, y)

The output looks like this:
42 17 4 17
42 15 3 4

162. GLOBAL VARIABLES IN NESTED FUNCTIONS

This means that the global keyword in nested functions does
not affect the namespace of their enclosing namespace!

def f():
city = "Hamburg"
def g():
global city
city = "Geneva"
print("Before calling g: " + city)
print("Calling g now:")
g()
print("After calling g: " + city)
f()
print("Value of city in main: " + city)
This program returns the following results:
Before calling g: Hamburg
Calling g now:
After calling g: Hamburg
Value of city in main: Geneva

163.
def f():
nonlocal city
print(city)
city = "Frankfurt"
f()

We get the following error:
File "/home/bernd/nested_globals.py", line 2
nonlocal city
^
SyntaxError: no binding for nonlocal 'city' found

164.
def f():
city = "Munich"
def g():
nonlocal city
city = "Zurich"
print("Before calling g: " + city)
print("Calling g now:")
g()
print("After calling g: " + city)
city = "Stuttgart"
f()
print("'city' in main: " + city)
Calling the previous program results in the following output:
Before calling g: Munich
Calling g now:
After calling g: Zurich
'city' in main: Stuttgart

165.
def f():
#city = "Munich"
def g():
nonlocal city
city = "Zurich"
print("Before calling g: " + city)
print("Calling g now:")
g()
print("After calling g: " + city)
city = "Stuttgart"
f()
print("'city' in main: " + city)
We get the following error message:
File "/home/bernd/nested_globals.py", line 4
nonlocal city
^
SyntaxError: no binding for nonlocal 'city' found

166.
def f():
#city = "Munich"
def g():
global city
city = "Zurich"
print("Before calling g: " + city)
print("Calling g now:")
g()
print("After calling g: " + city)
city = "Stuttgart"
f()
print("'city' in main: " + city)
This leads to the following output:
Before calling g: Stuttgart
Calling g now:
After calling g: Zurich
'city' in main: Zurich
Yet there is a huge difference: The value of the global x is changed now!

############################################################################################################
HISTORY OF PYTHON

167.
In an interview with Bill Venners1, Guido van Rossum said: "In the early 1980s, I worked as an implementer
on a team building a language called ABC at Centrum voor Wiskunde en Informatica
(CWI). I don't know how well people know ABC's influence on Python. I try to
mention ABC's influence because I'm indebted to everything I learned during that
project and to the people who worked on it."
Later on in the same Interview, Guido van Rossum continued: "I remembered all my
experience and some of my frustration with ABC. I decided to try to design a simple
scripting language that possessed some of ABC's better properties, but without its
problems. So I started typing. I created a simple virtual machine, a simple parser, and a
simple runtime. I made my own version of the various ABC parts that I liked.
I created a basic syntax, used indentation for statement grouping instead of curly braces or beginend
blocks, and developed a small number of powerful data types: a hash table (or
dictionary, as we call it), a list, strings, and numbers.

168. what about the name "Python" ?
Guido van Rossum, the creator of Python, wrote in 1996 about the origin of the name of his
programming language1: "Over six years ago, in December 1989, I was looking for a
'hobby' programming project that would keep me occupied during the week around
Christmas. My office ... would be closed, but I had a home computer, and not much else
on my hands. I decided to write an interpreter for the new scripting language I had been
thinking about lately: a descendant of ABC that would appeal to Unix/C hackers. I
chose Python as a working title for the project, being in a slightly irreverent mood (and
a big fan of Monty Python's Flying Circus)."

169. Guido Van Rossum published the first version of Python code (version 0.9.0) at
alt.sources in February 1991.

############################################################################################################
INHERITANCE

170. Inheritance supports code reusability. The methods or generally speaking the software inherited by a subclass
is considered to be reused in the subclass.

171.(a) The class from which a class inherits is called the parent or superclass.
    (b) A class which inherits from a superclass is called a subclass, also called heir class or child class.

172. DIFFERENCE BETWEEN TYPE AND ISINSTANCE

class Robot:
    def __init__(self, name):
	self.name = name
    def say_hi(self):
	print("Hi, I am " + self.name)
    class PhysicianRobot(Robot):
	pass
		
x = Robot("Marvin")
y = PhysicianRobot("James")
print(x, type(x))
print(y, type(y))

y.say_hi()
<__main__.Robot object at 0x7fd0080b3ba8> <class
'__main__.Robot'>
<__main__.PhysicianRobot object at 0x7fd0080b3b70>
<class '__main__.PhysicianRobot'>
Hi, I am James

x = Robot("Marvin")
y = PhysicianRobot("James")
print(isinstance(x, Robot), isinstance(y, Robot))
print(isinstance(x, PhysicianRobot))
print(isinstance(y, PhysicianRobot))
print(type(y) == Robot, type(y) == PhysicianRobot)
True True
False
True
False True

Now it should be clear, why PEP 8, the official Style Guide for Python code, says:
"Object type comparisons should always use isinstance() instead of comparing types
directly."

173. Now it should be clear, why PEP 8, the official Style Guide for Python code, says:
"Object type comparisons should always use isinstance() instead of comparing types
directly."

174. OVERRIDING

class Robot:
    def __init__(self, name):
        self.name = name

    def say_hi(self):
        print("Hi, I am " + self.name)

class PhysicianRobot(Robot):
    def say_hi(self):
        print("Everything will be okay! ")
        print(self.name + " takes care of you!")

y = PhysicianRobot("James")
y.say_hi()

O/P :
Everything will be okay! 
James takes care of you!
>>> 

175. 
class Robot:
def __init__(self, name):
self.name = name
def say_hi(self):
print("Hi, I am " + self.name)

M1
--
class PhysicianRobot(Robot):
def say_hi(self):
super().say_hi()
print("and I am a physician!")
doc = PhysicianRobot("Dr. Frankenstein")
doc.say_hi()

O/P
Hi, I am Dr. Frankenstein
and I am a physician!

M2
--
class PhysicianRobot(Robot):
def say_hi(self):
Robot.say_hi(self)
print("and I am a physician!")
doc = PhysicianRobot("Dr. Frankenstein")
doc.say_hi()

O/P
Hi, I am Dr. Frankenstein
and I am a physician!

super is not realls necessary in this case. One could argue that it makes the code more
maintainable, because we could change the name of the parent class, but this is seldom
done anyway in existing classes. The real benefit of super shows when we use it with
multiple inheritance.

DISTINCTION BETWEEN OVERWRITING, OVERLOADING AND OVERRIDING

176. OVERWRITING
If we overwrite a function, the original function will be gone. The function will be
redefined.

def f(x):
return x + 42
print(f(3))
# f will be overwritten (or redefined) in the
following:
def f(x):
return x + 43
print(f(3))
45
46

177. OVERLOADING
Overloading is the ability to define a function with the same name multiple times.
https://www.geeksforgeeks.org/python-method-overloading/

In the above code we have defined two product method, but we can only use the second product method, as python does not
supports method overloading. We may define many method of same name and different argument but we can only use the latest
defined method. Calling the other method will produce an error. Like here calling product(4, 5) will produce an error as
the latest defined product method takes three arguments.

178. OVERRIDING
https://www.geeksforgeeks.org/method-overriding-in-python/
Method overriding is an ability of any object-oriented programming language that allows a subclass or child class to provide
a specific implementation of a method that is already provided by one of its super-classes or parent classes. 

# Program to define the use of super() 
# function in multiple inheritance 
class GFG1: 
	def __init__(self): 
		print('HEY !!!!!! GfG I am initialised(Class GEG1)') 
	
	def sub_GFG(self, b): 
		print('Printing from class GFG1:', b) 
	
# class GFG2 inherits the GFG1 
class GFG2(GFG1): 
	def __init__(self): 
		print('HEY !!!!!! GfG I am initialised(Class GEG2)') 
		super().__init__() 
	
	def sub_GFG(self, b): 
		print('Printing from class GFG2:', b) 
		super().sub_GFG(b + 1) 
	
# class GFG3 inherits the GFG1 ang GFG2 both 
class GFG3(GFG2): 
	def __init__(self): 
		print('HEY !!!!!! GfG I am initialised(Class GEG3)') 
		super().__init__() 
	
	def sub_GFG(self, b): 
		print('Printing from class GFG3:', b) 
		super().sub_GFG(b + 1) 
	
	
# main function 
if __name__ == '__main__': 
	
	# created the object gfg 
	gfg = GFG3() 
	
	# calling the function sub_GFG3() from class GHG3 
	# which inherits both GFG1 and GFG2 classes 
	gfg.sub_GFG(10) 

OUTPUT
HEY !!!!!! GfG I am initialised(Class GEG3)
HEY !!!!!! GfG I am initialised(Class GEG2)
HEY !!!!!! GfG I am initialised(Class GEG1)
Printing from class GFG3: 10
Printing from class GFG2: 11
Printing from class GFG1: 12

############################################################################################################
THE INTERPRETER , AN INTERACTIVE SHELL

179.
Similarly, a shell in operating systems lies between the kernel
of the operating system and the user.

>>> 3 + 2 * 4
11
>>>
The most recent output value is automatically stored by the interpreter in a special variable
with the name "_". So we can print the output from the recent example again by typing an
underscore after the prompt:
>>> _
11
>>>
The underscore can be used in other expressions like any other variable:
>>> _ * 3
33
>>>

The underscore variable is only available in the Python shell. It's NOT available in Python
scripts or programs.

180.
Multiplication on strings is defined, which is essentially a multiple concatenation:
>>> ".-." * 4
'.-..-..-..-.'
>>>

############################################################################################################
INHERITANCE EXAMPLE

181.
THE CLOCK CLASS

class Clock(object):
    def __init__(self,hours=0, minutes=0,
    seconds=0):
        self.__hours = hours
        self.__minutes = minutes
        self.__seconds = seconds

    def set(self,hours, minutes, seconds=0):
        self.__hours = hours
        self.__minutes = minutes
        self.__seconds = seconds

    def tick(self):
        """ Time will be advanced by one second"""
        if self.__seconds == 59:
            self.__seconds = 0
            if (self.__minutes == 59):
                self.__minutes = 0
                self.__hours = 0 if self.__hours==23 else self.__hours + 1
            else:
                self.__minutes += 1
        else:
            self.__seconds += 1

    def display(self):
        print("%d:%d:%d" % (self.__hours,
        self.__minutes, self.__seconds))

    def __str__(self):
        return "%2d:%2d:%2d" % (self.__hours,
        self.__minutes, self.__seconds)

x = Clock()
print(x)
for i in range(1000):
    x.tick()
print(x)

#############################

OUTPUT
 0: 0: 0
 0:16:40
>>> 

THE CALENDAR CLASS

class Calendar(object):
months = (31,28,31,30,31,30,31,31,30,31,30,31)
def __init__(self, day=1, month=1, year=1900):
self.__day = day
self.__month = month
self.__year = year
def leapyear(self,y):
if y % 4:
# not a leap year
return 0;
else:
if y % 100:
return 1;
else:
if y % 400:
return 0
else:
return 1;
def set(self, day, month, year):
self.__day = day
self.__month = month
self.__year = year
def get():
return (self, self.__day, self.__month,
self.__year)
def advance(self):
months = Calendar.months
max_days = months[self.__month-1]
if self.__month == 2:
max_days += self.leapyear(self.__year)
if self.__day == max_days:
self.__day = 1
if (self.__month == 12):
self.__month = 1
self.__year += 1
else:
self.__month += 1
else:
self.__day += 1
def __str__(self):
return str(self.__day)+"/"+
str(self.__month)+ "/"+ str(self.__year)
if __name__ == "__main__":
x = Calendar()
print(x)
x.advance()
print(x)

THE CALENDAR-CLOCK CLASS

from clock import Clock
from calendar import Calendar

class CalendarClock(Clock, Calendar):
  def __init__(self, day,month,year,hours=0, minutes=0,seconds=0):
  
Calendar.__init__(self, day, month, year)
Clock.__init__(self, hours, minutes,
seconds)
def __str__(self):
return Calendar.__str__(self) + ", " +
Clock.__str__(self)
if __name__ == "__main__":
x = CalendarClock(24,12,57)
print(x)
for i in range(1000):
x.tick()
for i in range(1000):
x.advance()
print(x)

############################################################################################################
INPUT FROM KEYBOARD

############################################################################################################
LAMBDA, FILTER, REDUCE AND MAP

182. If Guido van Rossum, the author of the programming language Python, had got his will, this chapter would
be missing in our tutorial.

183. We can see the result: lambda, map() and filter() are still part of core Python. Only
reduce() had to go; it moved into the module functools.

His reasoning for dropping them is like this:
- There is an equally powerful alternative to lambda, filter, map and reduce, i.e. list comprehension
- List comprehension is more evident and easier to understand
- Having both list comprehension and "Filter, map, reduce and lambda" is transgressing the Python motto
  "There should be one obvious way to solve a problem".
  
184. Some like it, others hate it and many are afraid of the lambda operator. 
     The lambda feature was added to Python due to the demand from Lisp programmers.

185. The general syntax of a lambda function is quite simple:
     lambda argument_list: expression
     
186. The argument list consists of a comma separated list of arguments and the expression is
     an arithmetic expression using these arguments. You can assign the function to a
     variable to give it a name.
     
     The following example of a lambda function returns the sum of its two arguments:
     >>> sum = lambda x, y : x + y
     >>> sum(3,4)
     7
     >>>
     
187. THE MAP() FUNCTION

As we have mentioned earlier, the advantage of the lambda operator can be seen when
it is used in combination with the map() function.
map() is a function which takes two arguments:

r = map(func, seq)

The first argument func is the name of a function and the second a sequence (e.g. a list)
seq. map() applies the function func to all the elements of the sequence seq.

With Python 3, map() returns an iterator.

188.
The following example illustrates the way of working of map():
>>> def fahrenheit(T):
... return ((float(9)/5)*T + 32)
...
>>> def celsius(T):
... return (float(5)/9)*(T-32)
...
>>> temperatures = (36.5, 37, 37.5, 38, 39)
>>> F = map(fahrenheit, temperatures)
>>> C = map(celsius, F)
>>>
>>> temperatures_in_Fahrenheit =
list(map(fahrenheit, temperatures))
>>> temperatures_in_Celsius = list(map(celsius,
temperatures_in_Fahrenheit))
>>> print(temperatures_in_Fahrenheit)
[97.7, 98.60000000000001, 99.5, 100.4, 102.2]
>>> print(temperatures_in_Celsius)
[36.5, 37.00000000000001, 37.5, 38.00000000000001,
39.0]
>>>

189.
By using lambda, we wouldn't have had
to define and name the functions fahrenheit() and celsius(). You can see this in the
following interactive session:
>>> C = [39.2, 36.5, 37.3, 38, 37.8]
>>> F = list(map(lambda x: (float(9)/5)*x + 32,
C))
>>> print(F)
[102.56, 97.7, 99.14, 100.4, 100.03999999999999]
>>> C = list(map(lambda x: (float(5)/9)*(x-32),
F))
>>> print(C)
[39.2, 36.5, 37.300000000000004,
38.00000000000001, 37.8]
>>>

190. FILTERING

The function

filter(function, sequence)

offers an elegant way to filter out all the elements of a sequence "sequence", for which
the function function returns True. i.e. an item will be produced by the iterator result of
filter(function, sequence) if item is included in the sequence "sequence" and if
function(item) returns True.

>>> fibonacci = [0,1,1,2,3,5,8,13,21,34,55]
>>> odd_numbers = list(filter(lambda x: x % 2,
fibonacci))
>>> print(odd_numbers)
[1, 1, 3, 5, 13, 21, 55]
>>> even_numbers = list(filter(lambda x: x % 2 ==
0, fibonacci))
>>> print(even_numbers)
[0, 2, 8, 34]
>>>
>>>
>>> # or alternatively:
...
>>> even_numbers = list(filter(lambda x: x % 2 -1,
fibonacci))
>>> print(even_numbers)
[0, 2, 8, 34]
>>>

191. Guido van Rossum hates reduce().

192. The function 
     reduce(func, seq)
     continually applies the function func() to the sequence seq. It returns a single value.

193.
>>> import functools
>>> functools.reduce(lambda x,y: x+y,
[47,11,42,13])
113
>>>

194. EXAMPLES OF REDUCE()

a. Determining the maximum of a list of numerical values by using reduce:
>>> from functools import reduce
>>> f = lambda a,b: a if (a > b) else b
>>> reduce(f, [47,11,42,102,13])
102
>>>

b. Calculating the sum of the numbers from 1 to 100:
>>> from functools import reduce
>>> reduce(lambda x, y: x+y, range(1,101))
5050

############################################################################################################
MAGIC METHODS AND OPERATOR OVERLOADING

195. Magic methods methods are sometimes called dunder methods!

196. When you create an instance x of
a class A with the statement "x = A()", Python will do the necessary calls to __new__
and __init__.

197. The __call__ method enables Python programmers to write classes where the instances behave like functions.
     Both functions and the instances of such classes are called callables.
     
198. The mechanism works like this: If we have an expression "x + y" and x is an instance of
class K, then Python will check the class definition of K. If K has a method __add__ it
will be called with x.__add__(y), otherwise we will get an error message.

199. OVERVIEW OF MAGIC METHODS

BINARY OPERATORS
Operator Method
+ object.__add__(self, other)
- object.__sub__(self, other)
* object.__mul__(self, other)
// object.__floordiv__(self, other)
/ object.__truediv__(self, other)
% object.__mod__(self, other)
** object.__pow__(self, other[, modulo])
<< object.__lshift__(self, other)
>> object.__rshift__(self, other)
& object.__and__(self, other)
^ object.__xor__(self, other)
| object.__or__(self, other)

EXTENDED ASSIGNMENTS
Operator Method
+= object.__iadd__(self, other)
-= object.__isub__(self, other)
*= object.__imul__(self, other)
/= object.__idiv__(self, other)
//= object.__ifloordiv__(self, other)
%= object.__imod__(self, other)
**= object.__ipow__(self, other[, modulo])
<<= object.__ilshift__(self, other)
>>= object.__irshift__(self, other)
&= object.__iand__(self, other)
^= object.__ixor__(self, other)
|= object.__ior__(self, other)

UNARY OPERATORS
Operator Method
- object.__neg__(self)
+ object.__pos__(self)
abs() object.__abs__(self)
~ object.__invert__(self)
complex() object.__complex__(self)
int() object.__int__(self)
long() object.__long__(self)
float() object.__float__(self)
oct() object.__oct__(self)
hex() object.__hex__(self

COMPARISON OPERATORS
Operator Method
< object.__lt__(self, other)
<= object.__le__(self, other)
== object.__eq__(self, other)
!= object.__ne__(self, other)
>= object.__ge__(self, other)
> object.__gt__(self, other)

200. 

>>> from unit_conversions import Length
>>> L = Length
>>> print(L(2.56,"m") + L(3,"yd") + L(7.8,"in") +
L(7.03,"cm"))
5.57162
>>>

class Length:
    __metric = {"mm" : 0.001, "cm" : 0.01, "m" :1, "km" : 1000,
                "in" : 0.0254, "ft" : 0.3048, "yd": 0.9144,
                "mi" : 1609.344 }
        
    def __init__(self, value, unit = "m" ):
        self.value = value
        self.unit = unit

    def Converse2Metres(self):
        return self.value * Length.__metric[self.unit]
    
    def __add__(self, other):
        l = self.Converse2Metres() + other.Converse2Metres()
        return Length(l / Length.__metric[self.unit], self.unit )

    def __str__(self):
        return str(self.Converse2Metres())

    def __repr__(self):
        return "Length(" + str(self.value) + ", '" + self.unit + "')"
    
if __name__ == "__main__":
    x = Length(4)
    print(x)
    y = eval(repr(x))
    z = Length(4.5, "yd") + Length(1)
    print(repr(z))
    print(z)

4
Length(5.593613298337708, 'yd')
5.1148

We use the method__iadd__ to implement the extended assignment:
def __iadd__(self, other):
    l = self.Converse2Metres() + other.Converse2Metres()
    self.value = l / Length.__metric[self.unit]
    return self

Now we are capable to write the following assignments:
x += Length(1)
x += Length(4, "yd")

def __add__(self, other):
    if type(other) == int or type(other) == float:
        l = self.Converse2Metres() + other
    else:
	l = self.Converse2Metres() + other.Converse2Metres()
	return Length(l / Length.__metric[self.unit], self.unit )

def __iadd__(self, other):
    if type(other) == int or type(other) == float:
        l = self.Converse2Metres() + other
    else:
        l = self.Converse2Metres() + other.Converse2Metres()
    self.value = l / Length.__metric[self.unit]
    return self
 
>>> from unit_conversions import Length
>>> x = Length(3, "yd") + 5
>>> x = 5 + Length(3, "yd")
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
TypeError: unsupported operand type(s) for +:
'int' and 'Length'
>>>

def __radd__(self, other):
if type(other) == int or type(other) ==
float:
l = self.Converse2Metres() +
otherLength.__radd__(Length(3, "yd"), 5)
else:
l = self.Converse2Metres() +
other.Converse2Metres()
return Length(l /
Length.__metric[self.unit], self.unit )

def __radd__(self, other):
return Length.__add__(self,other)

200. EXERCISES
1. Write a class with the name Ccy, similar to the previously defined Length class.
Ccy should contain values in various currencies, e.g. "EUR", "GBP" or "USD". An instance
should contain the amount and the currency unit.
The class, you are going to design as an excercise, might be best described with the
following example session:

>>> from currencies import Ccy
>>> v1 = Ccy(23.43, "EUR")
>>> v2 = Ccy(19.97, "USD")
>>> print(v1 + v2)
32.89 EUR
>>> print(v2 + v1)
31.07 USD
>>> print(v1 + 3) # an int or a float is
considered to be a EUR value
27.43 EUR
>>> print(3 + v1)
27.43 EUR
>>>

201. STANDARD CLASSES AS BASE CLASSES
     It's possible to use standard classes - like int, float, dict or lists - as base classes as well.
     
     We extend the list class by adding a push method:
     class Plist(list):
         def __init__(self, l):
             list.__init__(self, l)
         def push(self, item):
             self.append(item)

     if __name__ == "__main__":
         x = Plist([3,4])
         x.push(47)
         print(x)

This means that all the previously introduced binary and extended assignment operators
exist in the "reversed" version as well:
__radd__
__rsub__
__rmul__
...
and so on

202. THE __CALL__ METHOD
The __call__ method can be used to turn the instances of the class into callables.
Functions are callable objects. A callable object is an object which can be used and
behaves like a function but might not be a function. By using the __call__ method it is
possible to define classes in a way that the instances will be callable objects. The
__call__ method is called, if the instance is called "like a function", i.e. using brackets.
The following example defines a class with which we can create abitrary polynomial
functions:

class Polynomial:
def __init__(self, *coefficients):
self.coefficients = coefficients[::-1]
def __call__(self, x):
res = 0
for index, coeff in
enumerate(self.coefficients):
res += coeff * x** index
return res
# a constant function
p1 = Polynomial(42)
# a straight Line
p2 = Polynomial(0.75, 2)
# a third degree Polynomial
p3 = Polynomial(1, -0.5, 0.75, 2)
for i in range(1, 10):
print(i, p1(i), p2(i), p3(i))

These are the results of the previous function:
1 42 2.75 3.25
2 42 3.5 9.5
3 42 4.25 26.75
4 42 5.0 61.0
5 42 5.75 118.25
6 42 6.5 204.5
7 42 7.25 325.75
8 42 8.0 488.0
9 42 8.75 697.25

############################################################################################################
MEMOIZATION WITH DECORATORS

203. Memoisation is a technique used in computing to speed up programs.
This is accomplished by memorizing the calculation results of processed input such as the results of function
calls. If the same input or a function call with the same parameters is used, the previously stored results
can be used again and unnecessary calculation are avoided.

204. memoize() takes a function as an argument. The function memoize uses a dictionary "memo" to store the
function results. Though the variable "memo" as well as the function "f" are local to
memoize, they are captured by a closure through the helper function which is returned
as a reference by memoize(). So, the call memoize(fib) returns a reference to the
helper() which is doing what fib() would do on its own plus a wrapper which saves the
calculated results.

205. 
# M1
def memoize(f):
  memo = {}
  def helper(x):
    if x not in memo:
      memo[x] = f(x)
    return memo[x]
  return helper

def fib(n):
  if n == 0:
    return 0
  elif n == 1:
    return 1
  else:
    return fib(n-1) + fib(n-2)

fib = memoize(fib)
print(fib(40))

# M2
def memoize(f):
  memo = {}
  def helper(x):
    if x not in memo:
      memo[x] = f(x)
    return memo[x]
  return helper

@memoize
def fib(n):
  if n == 0:
    return 0
  elif n == 1:
    return 1
  else:
    return fib(n-1) + fib(n-2)

print(fib(40))

# USING A CALLABLE CLASS FOR MEMOIZATION

206. We can encapsulate the caching of the results in a class as well, as you can see in the
following example:-

class Memoize:
  def __init__(self, fn):
    self.fn = fn
    self.memo = {}
    
  def __call__(self, *args):
    if args not in self.memo:
      self.memo[args] = self.fn(*args)
      return self.memo[args]
    
@Memoize
def fib(n):
  if n == 0:
    return 0
  elif n == 1:
    return 1
  else:
    return fib(n-1) + fib(n-2)

As we are using a dictionary, we can't use mutable arguments, i.e. the arguments have
to be immutable.

EXERCISE

1. Our exercise is an old riddle, going back to 1612. The French Jesuit Claude-
Gaspar Bachet phrased it. We have to weigh quantities (e.g. sugar or flour) from 1
to 40 pounds. What is the least number of weights that can be used on a balance
scale to way any of these quantities.The first idea might be to use
weights of 1, 2, 4, 8, 16 and 32 pounds. This is a minimal number,
if we restrict ourself to put weights on one side and the stuff, e.g. the
sugar, on the other side. But it is possible to put weights on both
pans of the scale. Now, we need only four weights, i.e. 1, 3, 9, 27
Write a Python function weigh(), which calculates the weights needed and their distribution
on the pans to weigh any amount from 1 to 40.

############################################################################################################
META CLASSES

207. A metaclass is a class whose instances are classes. Like an "ordinary" class defines
the behavior of the instances of the class, a metaclass defines the behavior of classes
and their instances.

208. There are numerous use cases for metaclasses. Just to name a few:

logging and profiling
interface checking
registering classes at creation time
automatically adding new methods
automatic property creation
proxies
automatic resource locking/synchronization.

209. DEFINING METACLASSES

- Principially, metaclasses are defined like any other Python class, but they are classes that inherit from "type".
- Another difference is, that a metaclass is called automatically, when the class statement using a metaclass ends.
- In other words: If no "metaclass" keyword is passed after the base classes (there may be no base classes either) of the
  class header, type() (i.e. __call__ of type) will be called.If a metaclass keyword is used
  on the other hand, the class assigned to it will be called instead of type.

210.
class LittleMeta(type):
  def __new__(cls, clsname, superclasses, attributedict):
    print("clsname: ", clsname)
    print("superclasses: ", superclasses)
    print("attributedict: ", attributedict)
    return type.__new__(cls, clsname, superclasses, attributedict)
  
class S:
    pass
class A(S, metaclass=LittleMeta):
    pass

a = A()

OUTPUT
>>> 
clsname:  A
superclasses:  (<class '__main__.S'>,)
attributedict:  {'__module__': '__main__', '__qualname__': 'A'}
>>> 
We can see LittleMeta.__new__ has been called and not type.__new__.

210.
x = input("Do you need the answer? (y/n): ")
if x.lower() == "y":
required = True
else:
required = False
def the_answer(self, *args):
return 42
class EssentialAnswers(type):
def __init__(cls, clsname, superclasses,
attributedict):
if required:
cls.the_answer = the_answer
class Philosopher1(metaclass=EssentialAnswers):
pass
class Philosopher2(metaclass=EssentialAnswers):
pass
class Philosopher3(metaclass=EssentialAnswers):
pass
plato = Philosopher1()
print(plato.the_answer())
kant = Philosopher2()
# let's see what Kant has to say :-)
print(kant.the_answer())
Do you need the answer? (y/n): y
42
42

211. We have learned in our chapter "Type and Class Relationship" that after the class
definition has been processed, Python calls type(classname, superclasses, attributes_dict)
This is not the case, if a metaclass has been declared in the header.
Our classes Philosopher1, Philosopher2 and
Philosopher3 have been hooked to the metaclass EssentialAnswers. That's why
EssentialAnswer will be called instead of type:
EssentialAnswer(classname, superclasses,
attributes_dict)
To be precise, the arguments of the calls will be set the the following values:
EssentialAnswer('Philopsopher1',
(),
{'__module__': '__main__',
'__qualname__': 'Philosopher1'})

CREATING SINGLETONS USING METACLASSES

212. The singleton pattern is a design pattern that restricts the instantiation of a class to one
object. It is used in cases where exactly one object is needed.

class Singleton(type):
_instances = {}
def __call__(cls, *args, **kwargs):
if cls not in cls._instances:
cls._instances[cls] = super(Singleton,
cls).__call__(*args, **kwargs)
return cls._instances[cls]
class SingletonClass(metaclass=Singleton):
pass
class RegularClass():
pass
x = SingletonClass()
y = SingletonClass()
print(x == y)
x = RegularClass()
y = RegularClass()
print(x == y)
True
False

CREATING SINGLETONS USING METACLASSES
213. 
Alternatively, we can create Singleton classes by inheriting from a Singleton class,
which can be defined like this:

class Singleton(object):
_instance = None
def __new__(cls, *args, **kwargs):
if not cls._instance:
cls._instance = object.__new__(cls,
*args, **kwargs)
return cls._instance
class SingletonClass(Singleton):
pass
class RegularClass():
pass
x = SingletonClass()
y = SingletonClass()
print(x == y)
x = RegularClass()
y = RegularClass()
print(x == y)
True
False

########################################################################################
SLOTS

AVOIDING DYNAMICALLY CREATED ATTRIBUTES

214. The attributes of objects are stored in a dictionary "__dict__".

215. Like any other
dictionary, a dictionary used for attribute
storage doesn't have a fixed number of
elements. In other words, you can add
elements to dictionaries after they have
been defined, as we have seen in our
chapter on dictionaries. This is the
reason, why you can dynamically add
attributes to objects of classes that we
have created so far:
- 
>>> class A(object):
... pass
...
>>> a = A()
>>> a.x = 66
>>> a.y = "dynamically
created attribute"

216.  The dictionary containing the attributes
of "a" can be accessed like this:
>>> a.__dict__
{'y': 'dynamically created attribute', 'x': 66}

217. 
You might have wondered that you can dynamically add attributes to the classes, we
have defined so far, but that you can't do this with built-in classes like 'int', or 'list':

218. 
Using a dictionary for attribute storage is very convenient, but it can mean a waste of
space for objects, which have only a small amount of instance variables. The space
consumption can become critical when creating large numbers of instances. Slots are a
nice way to work around this space consumption problem. Instead of having a dynamic
dict that allows adding attributes to objects dynamically, slots provide a static structure
which prohibits additions after the creation of an instance.

219. 
When we design a class, we can use slots to prevent the dynamic creation of attributes.
To define slots, you have to define a list with the name __slots__. The list has to
contain all the attributes, you want to use. We demonstrate this in the following class, in
which the slots list contains only the name for an attribute "val".
class S(object):
__slots__ = ['val']
def __init__(self, v):
self.val = v
x = S(42)
print(x.val)
x.new = "not possible"

-
If we start this program, we can see, that it is not possible to create dynamically a new
attribute. We fail to create an attribute "new":
42
Traceback (most recent call last):
File "slots_ex.py", line 12, in <module>
x.new = "not possible"
AttributeError: 'S' object has no attribute 'new'

220.
We mentioned in the beginning that slots are preventing a waste of space with objects.
Since Python 3.3 this advantage is not as impressive any more. With Python 3.3 Key-
Sharing Dictionaries are used for the storage of objects. The attributes of the instances
are capable of sharing part of their internal storage between each other, i.e. the part
which stores the keys and their corresponding hashes. This helps to reduce the memory
consumption of programs, which create many instances of non-builtin types.


###########################################################################################
LOOPS

221.
Python has these three channels as well:
standard input
standard output
standard error
They are contained in the module sys. Their names are:
sys.stdin
sys.stdout
sys.stderror

222.
The following script shows how to read with a while loop character by character from
standard input (keyboard).
import sys
text = ""
while 1:
c = sys.stdin.read(1)
text = text + c
if c == '\n':
break
print("Input: %s" % text)
Though it's possible to read input like this, usually the function input() is used.
>>> name = input("What's your name?\n")
What's your name?
Tux
>>> print(name)
Tux
>>>

223. The statements in the else part are
executed, when the condition is not
fulfilled anymore.
The general syntax of a while loop looks like this:

while condition:
statement_1
statement_n
else:
statement_1
...
statement_n

224. Now comes the crucial point: If a loop is
left by break, the else part is not
executed.

225. A little guessing number game.

A human player has to guess a number between a range of 1 to n. The player
inputs his guess. The program informs the player, if this number is larger, smaller or
equal to the secret number, i.e. the number which the program has randomly created. If
the player wants to gives up, he or she can input a 0 or a negative number.

import random
n = 20
to_be_guessed = int(n * random.random()) + 1
guess = 0
while guess != to_be_guessed:
guess = int(input("New number: "))
if guess > 0:
if guess > to_be_guessed:
print("Number too large")
elif guess < to_be_guessed:
print("Number too small")
else:
print("Sorry that you're giving up!")
break
else:
print("Congratulation. You made it!")
The output of a game session might look like this:
$ python3 number_game.py
New number: 12
Number too small
New number: 15
Number too small
New number: 18
Number too large
New number: 17
Congratulation. You made it!
$

SHALLOW AND DEEP COPY

226. 
In this chapter, we will cover the question of how to copy lists and nested lists.

>>> x = 3
>>> y = x
>>> print(id(x), id(y))
9251744 9251744
>>> y = 4
>>> print(id(x), id(y))
9251744 9251776
>>> print(x,y)
3 4
>>>

227. 
COPYING A LIST

>>> colours1 = ["red", "blue"]
>>> colours2 = colours1
>>> print(colours1)
['red', 'blue']
>>> print(colours2)
['red', 'blue']
>>> print(id(colours1),id(colours2))
43444416 43444416
>>> colours2 = ["rouge", "vert"]
>>> print(colours1)
['red', 'blue']
>>> print(colours2)
['rouge', 'vert']
>>> print(id(colours1),id(colours2))
43444416 43444200
>>>

228. 
In the example above a simple list is assigned to colours1. This list is a so-called
"shallow list", because it doesn't have a nested structure, i.e. no sublists are contained in
the list. In the next step we assign colour1 to colours2.

>>> colours1 = ["red", "blue"]
>>> colours2 = colours1
>>> print(id(colours1),id(colours2))
14603760 14603760
>>> colours2[1] = "green"
>>> print(id(colours1),id(colours2))
14603760 14603760
>>> print(colours1)
['red', 'green']
>>> print(colours2)
['red', 'green']
>>>

COPY WITH THE SLICE OPERATOR

229.
It's possible to completely copy shallow list structures with the slice operator without
having any of the side effects, which we have described above:
>>> list1 = ['a','b','c','d']
>>> list2 = list1[:]
>>> list2[1] = 'x'
>>> print(list2)
['a', 'x', 'c', 'd']
>>> print(list1)
['a', 'b', 'c', 'd']
>>>
But as soon as a list contains sublists, we have another difficulty: The sublists are not
copied but only the references to the sublists. The following example list "lst2" contains
one sublist. We create a shallow copy with the slicing operator.
>>> lst1 = ['a','b',['ab','ba']]
>>> lst2 = lst1[:]

230. 
If you assign a new value to the 0th or the 1st index of one of the two lists, there will be
no side effect.
>>> lst1 = ['a','b',['ab','ba']]
>>> lst2 = lst1[:]
>>> lst2[0] = 'c'
>>> print(lst1)
['a', 'b', ['ab', 'ba']]
>>> print(lst2)
['c', 'b', ['ab', 'ba']]
of the elements of the sublist:
>>> lst2[2][1] = 'd'
>>> print(lst1)
['a', 'b', ['ab', 'd']]
>>> print(lst2)
['c', 'b', ['ab', 'd']]


USING THE METHOD DEEPCOPY FROM THE MODULE COPY

231.
Let's use deepcopy for our previous list:
>>> from copy import deepcopy
>>>
>>> lst1 = ['a','b',['ab','ba']]
>>>
>>> lst2 = deepcopy(lst1)
>>>
>>> lst1
['a', 'b', ['ab', 'ba']]
>>> lst2
['a', 'b', ['ab', 'ba']]
>>> id(lst1)
139716507600200
>>> id(lst2)
139716507600904
>>> id(lst1[0])
139716538182096
>>> id(lst2[0])
139716538182096
>>> id(lst2[2])
139716507602632
>>> id(lst1[2])
139716507615880
>>>

The following diagram shows the situation after copying the list:
>>> lst2[2][1] = "d"
>>> lst2[0] = "c"
>>> print(lst1)
['a', 'b', ['ab', 'ba']]
>>> print(lst2)
['c', 'b', ['ab', 'd']]
>>>

ABSTRACT CLASSES

232. Abstract classes are classes that contain one or more abstract methods.

233. An abstract method is a method that is declared, but contains no implementation.

234. Abstract classes may not be instantiated, and require subclasses to provide
implementations for the abstract methods.

235.
The following Python code uses the abc module and defines an abstract base class:
from abc import ABC, abstractmethod
class AbstractClassExample(ABC):
def __init__(self, value):
self.value = value
super().__init__()
@abstractmethod
def do_something(self):
pass

We will define now a subclass using the previously defined abstract class. You will
notice that we haven't implemented the do_something method, even though we are
required to implement it, because this method is decorated as an abstract method with
the decorator "abstractmethod". We get an exception that DoAdd42 can't be
instantiated:
class DoAdd42(AbstractClassExample):
pass
x = DoAdd42(4)
The previous Python code returned the following output:
--------------------------------------------------
-------------------------
TypeError
Traceback (most recent call last)
<ipython-input-9-83fb8cead43d> in <module>()

2 pass
3
----> 4 x = DoAdd42(4)
TypeError: Can't instantiate abstract class
DoAdd42 with abstract methods do_something


class DoAdd42(AbstractClassExample):
def do_something(self):
return self.value + 42
class DoMul42(AbstractClassExample):
def do_something(self):
return self.value * 42
x = DoAdd42(10)
y = DoMul42(10)
print(x.do_something())
print(y.do_something())
52
420

236. A class that is derived from an abstract class cannot be instantiated unless all of its
abstract methods are overridden.

237. An abstract method can have an implementation in the
abstract class! Even if they are implemented, designers of subclasses will be forced to
override the implementation. Like in other cases of "normal" inheritance, the abstract
method can be invoked with super() call mechanism. This makes it possible to provide
some basic functionality in the abstract method, which can be enriched by the subclass
implementation.

from abc import ABC, abstractmethod
class AbstractClassExample(ABC):
@abstractmethod
def do_something(self):
print("Some implementation!")
class AnotherSubclass(AbstractClassExample):
def do_something(self):
super().do_something()
print("The enrichment from
AnotherSubclass")
x = AnotherSubclass()
x.do_something()
Some implementation!
The enrichment from AnotherSubclass

###########################################################################################
SEQUENTIAL DATA TYPES

238. 

Python provides for six sequence (or sequential) data types:

strings
byte sequences
byte arrays
lists
tuples
range objects

239. Where is the benefit of tuples?

Tuples are faster than lists.
If you know that some data doesn't have to be changed, you should use tuples
instead of lists, because this protects your data against accidental changes.
The main advantage of tuples consists in the fact that tuples can be used as keys in
dictionaries, while lists can't.

240.
In the following example we define a string and we print every third character of this
string:
>>> str = "Python under Linux is great"
>>> str[::3]
'Ph d n e'

241.
The following string, which looks like letter salad, contains two sentences. One of them
contains covert advertising of my Python courses in Canada:
"TPoyrtohnotno ciosu rtshees lianr gTeosrto
nCtiot yb yi nB oCdaennasdeao"
Try to figure it out using slicing with the step argument. The solution is: You have to set
step to 2
>>> s
'TPoyrtohnotno ciosu rtshees lianr gTeosrto
nCtiot yb yi nB oCdaennasdeao'
>>> s[::2]
'Toronto is the largest City in Canada'
>>> s[1::2]
'Python courses in Toronto by Bodenseo'
>>>

You may be interested in how we created the string. You have to understand list
comprehension to understand the following:
>>> s = "Toronto is the largest City in Canada"
>>> t = "Python courses in Toronto by Bodenseo"
>>> s = "".join(["".join(x) for x in zip(s,t)])
>>> s
'TPoyrtohnotno ciosu rtshees lianr gTeosrto
nCtiot yb yi nB oCdaennasdeao'
>>>

242.
It's a kind of abbreviation for an n-times concatenation, i.e.
str * 4
is the same as
str + str + str + str

243. THE PITFALLS OF REPETITIONS

>>> x = ["a","b","c"]
>>> y = [x] * 4
>>> y
[['a', 'b', 'c'], ['a', 'b', 'c'], ['a', 'b',
'c'], ['a', 'b', 'c']]
>>> y[0][0] = "p"
>>> y
[['p', 'b', 'c'], ['p', 'b', 'c'], ['p', 'b',
'c'], ['p', 'b', 'c']]
>>>


###########################################################################################
SETS AND FROZEN SETS

244. A set contains an unordered collection of unique and immutable objects.

This explains, why sets unlike lists or tuples can't have
multiple occurrences of the same element.

245. SETS

>>> x = set("A Python Tutorial")
>>> x
{'A', ' ', 'i', 'h', 'l', 'o', 'n', 'P', 'r', 'u',
't', 'a', 'y', 'T'}
>>> type(x)
<class 'set'>
>>>

246. 
>>> cities = set(("Paris", "Lyon",
"London","Berlin","Paris","Birmingham"))
>>> cities
{'Paris', 'Birmingham', 'Lyon', 'London',
'Berlin'}
>>>

247. IMMUTABLE SETS
Sets are implemented in a way, which doesn't allow mutable objects. The following
example demonstrates that we cannot include, for example, lists as elements:
>>> cities = set((("Python","Perl"), ("Paris",
"Berlin", "London")))
>>> cities = set((["Python","Perl"], ["Paris",
"Berlin", "London"]))
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
TypeError: unhashable type: 'list'
>>>

248. FROZENSETS

Though sets can't contain mutable objects, sets are mutable:

>>> cities = set(["Frankfurt",
"Basel","Freiburg"])
>>> cities.add("Strasbourg")
>>> cities
{'Freiburg', 'Basel', 'Frankfurt', 'Strasbourg'}
>>>

Frozensets are like sets except that they cannot be changed, i.e. they are immutable:
>>> cities = frozenset(["Frankfurt",
"Basel","Freiburg"])
>>> cities.add("Strasbourg")
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
AttributeError: 'frozenset' object has no
attribute 'add'
>>>

249. IMPROVED NOTATION

We can use curly braces instead:
>>> adjectives =
{"cheap","expensive","inexpensive","economical"}
>>> adjectives
{'inexpensive', 'cheap', 'expensive',
'economical'}
>>>

SET OPERATIONS

250. ADD(ELEMENT)

A method which adds an element, which has to be immutable, to a set.
>>> colours = {"red","green"}
>>> colours.add("yellow")
>>> colours
{'green', 'yellow', 'red'}
>>> colours.add(["black","white"])
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
TypeError: unhashable type: 'list'
>>>
Of course, an element will only be added, if it is not already contained in the set.
If it is already contained, the method call has no effect.

251. CLEAR()

All elements will be removed from a set.
>>> cities = {"Stuttgart", "Konstanz",
"Freiburg"}
>>> cities.clear()
>>> cities
set()
>>>

252. COPY

Creates a shallow copy, which is returned.
>>> more_cities =
{"Winterthur","Schaffhausen","St. Gallen"}
>>> cities_backup = more_cities.copy()
>>> more_cities.clear()
>>> cities_backup
{'St. Gallen', 'Winterthur', 'Schaffhausen'}
>>>
Just in case, you might think, an assignment might be enough:
>>> more_cities =
{"Winterthur","Schaffhausen","St. Gallen"}
>>> cities_backup = more_cities
>>> more_cities.clear()
>>> cities_backup
set()
>>>

253. DIFFERENCE()

This method returns the difference of two or more sets as a new set.
>>> x = {"a","b","c","d","e"}
>>> y = {"b","c"}
>>> z = {"c","d"}
>>> x.difference(y)
{'a', 'e', 'd'}
>>> x.difference(y).difference(z)
{'a', 'e'}
>>>
Instead of using the method difference, we can use the operator "-":
>>> x - y
{'a', 'e', 'd'}
>>> x - y - z
{'a', 'e'}
>>>

254. DIFFERENCE_UPDATE()

The method difference_update removes all elements of another set from this set.
x.difference_update(y) is the same as "x = x - y"
>>> x = {"a","b","c","d","e"}
>>> y = {"b","c"}
>>> x.difference_update(y)
>>>
>>> x = {"a","b","c","d","e"}
>>> y = {"b","c"}
>>> x = x - y
>>> x
{'a', 'e', 'd'}
>>>

255. DISCARD(EL)

An element el will be removed from the set, if it is contained in the set. If el is not
a member of the set, nothing will be done.
>>> x = {"a","b","c","d","e"}
>>> x.discard("a")
>>> x
{'c', 'b', 'e', 'd'}
>>> x.discard("z")
>>> x
{'c', 'b', 'e', 'd'}
>>>

256. REMOVE(EL)

works like discard(), but if el is not a member of the set, a KeyError will be
raised.
>>> x = {"a","b","c","d","e"}
>>> x.remove("a")
>>> x
{'c', 'b', 'e', 'd'}
>>> x.remove("z")
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
KeyError: 'z'
>>>

257. UNION(S)

This method returns the union of two sets as a new set, i.e. all elements that are in
either set.
>>> x = {"a","b","c","d","e"}
>>> y = {"c","d","e","f","g"}
>>> x.union(y)
{'d', 'a', 'g', 'c', 'f', 'b', 'e'}
This can be abbreviated with the pipe operator "|":
>>> x = {"a","b","c","d","e"}
>>> y = {"c","d","e","f","g"}
>>> x | y
{'d', 'a', 'g', 'c', 'f', 'b', 'e'}
>>>

258. INTERSECTION(S)

Returns the intersection of the instance set and the set s as a new set. In other
words: A set with all the elements which are contained in both sets is returned.
>>> x = {"a","b","c","d","e"}
>>> y = {"c","d","e","f","g"}
>>> x.intersection(y)
{'c', 'e', 'd'}
>>>
This can be abbreviated with the ampersand operator "&":
>>> x = {"a","b","c","d","e"}
>>> y = {"c","d","e","f","g"}
>>> x & y
{'c', 'e', 'd'}
>>>

259. ISDISJOINT()

This method returns True if two sets have a null intersection.
>>> x = {"a","b","c"}
>>> y = {"c","d","e"}
>>> x.isdisjoint(y)
False
>>>
>>> x = {"a","b","c"}
>>> y = {"d","e","f"}
>>> x.isdisjoint(y)
True
>>>

260. ISSUBSET()

x.issubset(y) returns True, if x is a subset of y. "<=" is an abbreviation for "Subset
of" and ">=" for "superset of"
"<" is used to check if a set is a proper subset of a set.
>>> x = {"a","b","c","d","e"}
>>> y = {"c","d"}
>>> x.issubset(y)
False
>>> y.issubset(x)
True
>>> x < y
False
>>> y < x # y is a proper subset of x
True
>>> x < x # a set can never be a proper subset
of oneself.
False
>>> x <= x
True
>>>

261. ISSUPERSET()

x.issuperset(y) returns True, if x is a superset of y. ">=" is an abbreviation for
"issuperset of"
">" is used to check if a set is a proper superset of a set.
>>> x = {"a","b","c","d","e"}
>>> y = {"c","d"}
>>> x.issuperset(y)
True
>>> x > y
True
>>> x >= y
True
>>> x >= x
True
>>> x > x
False
>>> x.issuperset(x)
True
>>>

262. POP()

pop() removes and returns an arbitrary set element. The method raises a KeyError
if the set is empty
>>> x = {"a","b","c","d","e"}
>>> x.pop()
'a'
>>> x.pop()
'c'

###########################################################################################
PRINT

263. PRINT FUNCTION

The arguments of the print function are the following ones:
print(value1, ..., sep=' ', end='\n',
file=sys.stdout, flush=False)

264. 
>>> print("a","b")
a b
>>> print("a","b",sep="")
ab
>>> print(192,168,178,42,sep=".")
192.168.178.42
>>> print("a","b",sep=":-)")
a:-)b
>>>

265. 
A print call is ended by a newline, as we can see in the following usage:
>>> for i in range(4):
... print(i)
...
0
1
2
3
>>>
To change this behaviour, we can assign an arbitrary string to the keyword parameter
"end". This string will be used for ending the output of the values of a print call:
>>> for i in range(4):
... print(i, end=" ")
...
0 1 2 3 >>>
>>> for i in range(4):
... print(i, end=" :-) ")
...
0 :-) 1 :-) 2 :-) 3 :-) >>>

266.

The output of the print function is send to the standard output stream (sys.stdout) by
default. By redefining the keyword parameter "file" we can send the output into a
different stream e.g. sys.stderr or a file:
>>> fh = open("data.txt","w")
>>> print("42 is the answer, but what is the
question?", file=fh)
>>> fh.close()
>>>
We can see that we don't get any output in the interactive shell. The output is sent to the
file "data.txt". It's also possible to redirect the output to the standard error channel this
way:
>>> import sys
>>> # output into sys.stderr:
...
>>> print("Error: 42", file=sys.stderr)
Error: 42


###########################################################################################
PACKAGES IN PYTHON

267. We learned that modules are files
containing Python statements and
definitions, like function and class
definitions. We will learn in this chapter
how to bundle multiple modules
together to form a package.

268. A package is basically a directory with
Python files and a file with the name
__init__.py. This means that every
directory inside of the Python path, which contains a file named __init__.py, will be
treated as a package by Python. It's possible to put several modules into a Package.

269. 
We will call our package "simple_package".
This directory needs to contain a file
with the name "__init__.py". This file
can be empty, or it can contain valid
Python code. This code will be executed
when a package will be imported, so it
can be used to initialize a package, e.g.
to make sure that some other modules
are imported or some values set. Now
we can put into this directory all the
Python files which will be the
submodules of our module.
We create two simple files a.py and b.py just for the sake of filling the package with
modules.
The content of a.py:
def bar():
print("Hello, function 'bar' from module 'a'
calling")
The content of b.py:
def foo():
print("Hello, function 'foo' from module 'b'
calling")
We will also add an empty file with the name __init__.py inside of simple_package
directory.
Let's see whats happening, when we import simple_package from the interactive
Python shell, assuming that the directory simple_package is either in the directory from
which you call the shell or that it is contained in the search path or environment
variable "PYTHONPATH" (from your operating system):


>>> import simple_package
>>>
>>> simple_package
<module 'simple_package' from '/home/bernd/Dropbox
(Bodenseo)/websites/pythoncourse.
eu/examples/simple_package/__init__.py'>
>>>
>>> simple_package/a
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
NameError: name 'a' is not defined
>>>
>>> simple_package/b
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
NameError: name 'b' is not defined

We can see that the package simple_package has been loaded but neither the module
"a" nor the module "b"! We can import the modules a and b in the following way:
>>> from simple_package import a, b
>>> a.bar()
Hello, function 'bar' from module 'a' calling
>>> b.foo()
Hello, function 'foo' from module 'b' calling
>>>

As we have seen at the beginning of the chapter, we can't access neither "a" nor "b" by
solely importing simple_package.
Yet, there is a way to automatically load these modules. We can use the file __init__.py
for this purpose. All we have to do is add the following lines to the so far empty file
__init__.py:
import simple_package.a
import simple_package.b

It will work now:
>>> import simple_package
>>>
>>> simple_package.a.bar()
Hello, function 'bar' from module 'a' calling
>>>
>>> simple_package.b.foo()
Hello, function 'foo' from module 'b' calling

270.
Python provides a mechanism to give an explicit index of the subpackages and modules
of a packages, which should be imported. For this purpose, we can define a list named
__all__. This list will be taken as the list of module and package names to be imported
when from package import * is encountered.
We will add now the line
__all__ = ["formats", "filters", "effects",
"foobar"]
to the __init__.py file of the sound directory. We get a completely different result now:
>>> from sound import *
sound package is getting imported!
formats package is getting imported!
filters package is getting imported!
effects package is getting imported!
The module foobar is getting imported
>>>

271.
Even though it is already apparent that all the modules have been imported, we can
check with dir again:
>>> dir()
['__builtins__', '__doc__', '__loader__',
'__name__', '__package__', '__spec__', 'effects',
'filters', 'foobar', 'formats']
>>>
The next question is what will be imported, if we use * in a subpackage:
>>> from sound.effects import *
sound package is getting imported!
effects package is getting imported!
>>> dir()
['__builtins__', '__doc__', '__loader__',
'__name__', '__package__', '__spec__']
>>>
Like expected the modules inside of effects have not been imported automatically. So
we can add the following __all__ list into the __init__ file of the package effects:
__all__ = ["echo", "surround", "reverse"]
Now we get the intended result:
>>> from sound.effects import *
sound package is getting imported!
effects package is getting imported!
Module echo.py has been loaded!
Module surround.py has been loaded!
Module reverse.py has been loaded!
>>>
>>> dir()
['__builtins__', '__doc__', '__loader__',
'__name__', '__package__', '__spec__', 'echo',
'reverse', 'surround']
>>>
Although certain modules are designed to export only names that follow certain
patterns when you use import *, it is still considered bad practice. The recommended
way is to import specific modules from a package instead of using *.

272.
|-- effects
| |-- echo.py
| |-- __init__.py
| |-- reverse.py
| `-- surround.py
|-- filters
| |-- equalizer.py
| |-- __init__.py
| |-- karaoke.py
| `-- vocoder.py
|-- formats
| |-- aiffread.py
| |-- aiffwrite.py
| |-- auread.py
| |-- auwrite.py
| |-- __init__.py
| |-- wavread.py
| `-- wavwrite.py
`-- __init__.py

It is also possible to automatically import the package formats, when we are importing
the effects package. We can also do this with a relative path, which we will include
into the __init__.py file of the directory effects:
from .. import formats

Importing sound will also automatically import the modules formats and effects:
>>> import sound
formats package is getting imported!
effects package is getting imported!
sound package is getting imported!

###########################################################################################
RECURSIVE FUNCTIONS

273. Termination condition:
A recursive function has to fulfil an important condition to be used in a program: it has to
terminate. A recursive function terminates, if with every recursive call the solution of the
problem is downsized and moves towards a base case. A base case is a case, where the
problem can be solved without further recursion. A recursion can end up in an infinite loop, if
the base case is not met in the calls.

274.
def factorial(n):
if n == 1:
return 1
else:
return n * factorial(n-1)

275. THE PITFALLS OF RECURSION

def fib(n):
if n == 0:
return 0
elif n == 1:
return 1
else:
return fib(n-1) + fib(n-2)


def fibi(n):
old, new = 0, 1
if n == 0:
return 0
for i in range(n-1):
old, new = new, old + new
return new

If you check the functions fib() and fibi(), you will find out that the iterative version fibi() is a
lot faster than the recursive version fib(). To get an idea of how much this "a lot faster" can be,
we have written a script, which uses the timeit module, to measure the calls. To do this, we
save the function definitions for fib and fibi in a file fibonacci.py, which we can import in the
program (fibonacci_runit.py) below:
from timeit import Timer
t1 = Timer("fib(10)","from fibonacci import fib")
for i in range(1,41):
s = "fib(" + str(i) + ")"
t1 = Timer(s,"from fibonacci import fib")
time1 = t1.timeit(3)
s = "fibi(" + str(i) + ")"
t2 = Timer(s,"from fibonacci import fibi")
time2 = t2.timeit(3)
print("n=%2d, fib: %8.6f, fibi: %7.6f,
percent: %10.2f" % (i, time1, time2, time1/time2))
time1 is the time in seconds it takes for 3 calls to fib(n) and time2 respectively the time for
fibi().

276.
We can implement a "memory" for our recursive version by using a dictionary to save the
previously calculated values.

memo = {0:0, 1:1}
def fibm(n):
if not n in memo:
memo[n] = fibm(n-1) + fibm(n-2)
return memo[n]
We time it again to compare it with fibi():

from timeit import Timer
from fibonacci import fib
t1 = Timer("fib(10)","from fibonacci import fib")
for i in range(1,41):
s = "fibm(" + str(i) + ")"
t1 = Timer(s,"from fibonacci import fibm")
time1 = t1.timeit(3)
s = "fibi(" + str(i) + ")"
t2 = Timer(s,"from fibonacci import fibi")
time2 = t2.timeit(3)
print("n=%2d, fib: %8.6f, fibi: %7.6f,
percent: %10.2f" % (i, time1, time2, time1/time2))
We can see that it is even faster than the iterative version. Of course, the larger the arguments
the greater the benefit of our memoization:
n= 1, fib: 0.000011, fibi: 0.000015, percent:
0.73
n= 2, fib: 0.000011, fibi: 0.000013, percent:
0.85

277.
We can also define a recursive algorithm for our Fibonacci function by using a class with
callabe instances, i.e. by using the special method __call__. This way, we will be able to hide
the dictionary in an elegant way. We used a general approach which allows as to define also
functions similar to Fibonacci, like the Lucas function:
class Fibonacci:
def __init__(self, i1=0, i2=1):
self.memo = {0:i1, 1:i2}
def __call__(self, n):
if n not in self.memo:
self.memo[n] = self.__call__(n-1) +
self.__call__(n-2)
return self.memo[n]
fib = Fibonacci()
lucas = Fibonacci(2, 1)
for i in range(1, 16):
print(i, fib(i), lucas(i))
The program returns the following output:
1 1 1
2 1 3
3 2 4
4 3 7
5 5 11
6 8 18
7 13 29
8 21 47
9 34 76
10 55 123
11 89 199
12 144 322
13 233 521
14 377 843
15 610 1364

278. EXERCISES
1. Think of a recusive version of the function f(n) = 3 * n, i.e. the multiples of 3
2. Write a recursive Python function that returns the sum of the first n integers.
(Hint: The function will be similiar to the factorial function!)
3. Write a function which implements the Pascal's triangle:
1
1 1
1 2 1
1 3 3 1
1 4 6 4 1
1 5 10 10 5 1
4. The Fibonacci numbers are hidden inside of Pascal's triangle. If you sum up the coloured
numbers of the following triangle, you will get the 7th Fibonacci number:
1
1 1
1 2 1
1 3 3 1
1 4 6 4 1
1 5 10 10 5 1
1 6 15 20 15 6 1
Write a recursive program to calculate the Fibonacci numbers, using Pascal's triangle.

5. Implement a recursive function in Python for the sieve of Eratosthenes.
The sieve of Eratosthenes is a simple algorithm for finding all prime numbers up to a
specified integer. It was created by the ancient Greek mathematician Eratosthenes.
The algorithm to find all the prime numbers less than or equal to a given integer n:
1. Create a list of integers from two to n: 2, 3, 4, ..., n
2. Start with a counter i set to 2, i.e. the first prime number
3. Starting from i+i, count up by i and remove those numbers from the list, i.e. 2*i,
3*i, 4*i, aso..
4. Find the first number of the list following i. This is the next prime number.
5. Set i to the number found in the previous step
6. Repeat steps 3 and 4 until i is greater than n. (As an improvement: It's enough to go
to the square root of n)
7. All the numbers, which are still in the list, are prime numbers
You can easily see that we would be inefficient, if we strictly used this algorithm, e.g. we
will try to remove the multiples of 4, although they have been already removed by the
multiples of 2. So it's enough to produce the multiples of all the prime numbers up to the
square root of n. We can recursively create these sets.
6. Write a recursive function find_index(), which returns the index of a number in the
Fibonacci sequence, if the number is an element of this sequence and returns -1 if the
number is not contained in it, i.e.
fib(find_index(n)) == n
7. The sum of the squares of two consecutive Fibonacci numbers is also a Fibonacci
number, e.g. 2 and 3 are elements of the Fibonacci sequence and 2*2 + 3*3 = 13
corresponds to Fib(7).
Use the previous function to find the position of the sum of the squares of two
consecutive numbers in the Fibonacci sequence.
Mathematical explanation:
Let a and b be two successive Fibonacci numbers with a prior to b. The Fibonacci
sequence starting with the number "a" looks like this:
0 a
1 b
2 a + b
3 a + 2b
4 2a + 3b
5 3a + 5b
6 5a + 8b
We can see that the Fibonacci numbers appear as factors for a and b. The n-th element in
this sequence can be calculated with the following formula:
F(n) = Fib(n-1)* a + Fib(n) * b
From this we can conclude that for a natural number n, n>1, the following holds true:
Fib(2*n + 1) = Fib(n)**2 + Fib(n+1)**2

###########################################################################################
ARITHMETIC AND COMPARISON OPERATORS

279. 
>>> 10 // 3
3
If at least one of the operands is a
float value, we get a truncated
float value as the result.
>>> 10.0 // 3
3.0
>>>
A note about efficiency:
The results of int(10 / 3) and 10 //
3 are equal. But the "//" division
is more than two times as fast!
You can see this here:
In [9]: %%timeit
for x in range(1,
100):
y = int(100 /
x)
...:
100000 loops, best
of 3: 11.1 μs per
loop
In [10]: %%timeit
for x in range(1,
100):
y = 100 // x
....:
100000 loops, best
of 3: 4.48 μs per
loop

280.
10 ** 3
Result: 1000

###########################################################################################
ADVANCED REGULAR EXPRESSIONS

281.
We can just use the findall method of the re
module:
re.findall(pattern, string[, flags])
findall returns all non-overlapping matches of pattern in string, as a list of strings. The
string is scanned left-to-right, and matches are returned in the order in which they are
found.

>>> t="A fat cat doesn't eat oat but a rat eats
bats."
>>> mo = re.findall("[force]at", t)
>>> print(mo)
['fat', 'cat', 'eat', 'oat', 'rat', 'eat']

282.
In the following example, we check, if one of the cities London, Paris, Zurich,
Konstanz Bern or Strasbourg appear in a string preceded by the word "location":
>>> import re
>>> str = "Course location is London or Paris!"
>>> mo = re.search(r"location.*
(London|Paris|Zurich|Strasbourg)",str)
>>> if mo: print(mo.group())
...
location is London or Paris
>>>

283.

If you consider the previous example as too artificial, here is another one. Let's assume,
you want to filter your email. You want to find all the correspondence (conversations)
between you and Guido van Rossum, the creator and designer of Python. The following
regular expression is helpful for this purpose:
r"(^To:|^From:) (Guido|van Rossum)"
This expression matches all lines starting with either 'To:' or 'From:', followed by a
space and then either by the first name 'Guido' or the surname 'van Rossum'.

284. COMPILING REGULAR EXPRESSIONS

If you want to use the same regexp more than once in a script, it might be a good idea
to use a regular expression object, i.e. the regex is compiled.
The general syntax:
re.compile(pattern[, flags])
compile returns a regex object, which can be used later for searching and replacing. The
expressions behaviour can be modified by specifying a flag value.

Abbreviation Full name Description
re.I re.IGNORECASE Makes the regular expression case-insensitive
re.L re.LOCALE
The behaviour of some special sequences like \w,
\W, \b,\s, \S will be made dependant on the current
locale, i.e. the user's language, country aso.
re.M re.MULTILINE
^ and $ will match at the beginning and at the end
of each line and not just at the beginning and the
end of the string
re.S re.DOTALL The dot "." will match every character plus the
newline
re.U re.UNICODE Makes \w, \W, \b, \B, \d, \D, \s, \S dependent on
Unicode character properties
re.X re.VERBOSE
Allowing "verbose regular expressions", i.e.
whitespace are ignored. This means that spaces,
tabs, and carriage returns are not matched as such.
If you want to match a space in a verbose regular
expression, you'll need to escape it by escaping it
with a backslash in front of it or include it in a
character class.
# are also ignored, except when in a character class
or preceded by an non-escaped backslash.
Everything following a "#" will be ignored until
the end of the line, so this character can be used to
start a comment.

285.
Compiled regular objects usually are not saving much time, because Python internally
compiles AND CACHES regexes whenever you use them with re.search() or
re.match(). The only extra time a non-compiled regex takes is the time it needs to check
the cache, which is a key lookup of a dictionary.
A good reason to use them is to separate the definition of a regex from its use.

286.
>>> import re
>>> regex = r"[A-z]{1,2}[0-9R][0-9A-Z]? [0-9][ABDHJLNP-
UW-Z]{2}"
>>> address = "BBC News Centre, London, W12 7RJ"
>>> compiled_re = re.compile(regex)
>>> res = compiled_re.search(address)
>>> print(res)
<_sre.SRE_Match object at 0x174e578>
>>>

287.

>>> mammon = "The god of the world's leading
religion. The chief temple is in the holy city of
New York."
>>> mammon.split(" ",3)
['The', 'god', 'of', "the world's leading
religion. The chief temple is in the holy city of
New York."]

288.
If multiple blanks or whitespaces are connected, split() will split the string after every
single blank, so that we will get empty strings and strings with only a tab inside ('\t') in
our result list:
>>> mammon = "The god \t of the world's leading
religion. The chief temple is in the holy city of
New York."
>>> mammon.split(" ",5)
['The', 'god', '', '\t', 'of', "the world's
leading religion. The chief temple is in the holy
city of New York."]
>>>
We can prevent the separation of empty strings by using None as the first argument.
Now split will use the default behaviour, i.e. every substring consisting of connected
whitespace characters will be taken as one separator:
>>> mammon.split(None,5)
['The', 'god', 'of', 'the', "world's", 'leading
religion. The chief temple is in the holy city of
New York.']

289. REGULAR EXPRESSION SPLIT

The string method split() is the right tool in many cases, but what, if you want e.g. to
get the bare words of a text, i.e. without any special characters and whitespaces. If we
want this, we have to use the split function from the re module.

>>> import re
>>> metamorphoses = "OF bodies chang'd to various
forms, I sing: Ye Gods, from whom these miracles
did spring, Inspire my numbers with coelestial
heat;"
>>> re.split("\W+",metamorphoses)
['OF', 'bodies', 'chang', 'd', 'to', 'various',
'forms', 'I', 'sing', 'Ye', 'Gods', 'from',
'whom', 'these', 'miracles', 'did', 'spring',
'Inspire', 'my', 'numbers', 'with', 'coelestial',
'heat', '']

290.
Let's assume that we have data lines with surnames, first names and
professions of names. We want to clear the data line of the superfluous and redundant
text descriptions, i.e. "surname: ", "prename: " and so on, so that we have solely the
surname in the first column, the first name in the second column and the profession in
the third column:
>>> import re
>>> lines = ["surname: Obama, prename: Barack,
profession: president", "surname: Merkel, prename:
Angela, profession: chancellor"]
>>> for line in lines:
... re.split(",* *\w*: ", line)
...
['', 'Obama', 'Barack', 'president']
['', 'Merkel', 'Angela', 'chancellor']
>>>
We can easily improve the script by using a slice operator, so that we don't have the
empty string as the first element of our result lists:
>>> import re
>>> lines = ["surname: Obama, prename: Barack,
profession: president", "surname: Merkel, prename:
Angela, profession: chancellor"]
>>> for line in lines:
... re.split(",* *\w*: ", line)[1:]
...
['Obama', 'Barack', 'president']
['Merkel', 'Angela', 'chancellor']
>>>

291. SEARCH AND REPLACE WITH SUB

re.sub(regex, replacement, subject)
Every match of the regular expression regex in the string subject will be replaced by the
string replacement.
Example:
>>> import re
>>> str = "yes I said yes I will Yes."
>>> res = re.sub("[yY]es","no", str)
>>> print(res)
no I said no I will no.

###########################################################################################
PYTHON TESTS

292. Even though it's hardly possible to
completely eliminate all errors in a software product, we should always work
ambitiously to this end, i.e. to keep the number of errors minimal.

293. Every module has a name, which is defined in the built-in attribute __name__. Let's
assume that we have written a module "xyz" which we have saved as "xyz.py". If we
import this module with "import xyz", the string "xyz" will be assigned to __name__.
If we call the file xyz.py as a standalone program, i.e. in the following way,
$python3 xyz.py
the value of __name__ will be the string '__main__'.

DOCTEST MODULE
294. 
The doctest module is often considered easier to use than the unittest, though the later is
more suitable for more complex tests. doctest is a test framework that comes
prepackaged with Python. The doctest module searches for pieces of text that look like
interactive Python sessions inside of the documentation parts of a module, and then
executes (or reexecutes) the commands of those sessions to verify that they work
exactly as shown, i.e. that the same results can be achieved. In other words: The help
text of the module is parsed, for example, python sessions. These examples are run and
the results are compared against the expected value.

Usage of doctest:
To use "doctest" it has to be imported. The part of an interactive Python sessions with
the examples and the output has to be copied inside of the docstring the corresponding
function.
We demonstrate this way of proceeding with the following simple example. We have
slimmed down the previous module, so that only the function fib is left:

import doctest
def fib(n):
"""
Calculates the n-th Fibonacci number
iteratively
>>> fib(0)
0
>>> fib(1)
1
>>> fib(10)
55
>>> fib(15)
610
>>>
"""
a, b = 0, 1
for i in range(n):
a, b = b, a + b
return a
if __name__ == "__main__":
doctest.testmod()
If we start our module directly like this
$ python3 fibonacci_doctest.py
we get no output, because everything is okay.
To see how doctest works, if something is wrong, we place an error in our code:
We change again
a, b = 0, 1
into
a, b = 1, 1
Now we get the following, if we start our module:
$ python3 fibonacci_doctest.py
**************************************************
********************
File "fibonacci_doctest.py", line 8, in
__main__.fib
Failed example:
fib(0)
Expected:
0
Got:
1
**************************************************
********************
File "fibonacci_doctest.py", line 12, in
__main__.fib
Failed example:
fib(10)
Expected:
55
Got:
89
**************************************************
********************
File "fibonacci_doctest.py", line 14, in
__main__.fib
Failed example:
fib(15)
Expected:
610
Got:
987
**************************************************
********************
1 items had failures:
3 of 4 in __main__.fib
***Test Failed*** 3 failures.

295. TEST-DRIVEN DEVELOPMENT (TDD)

What about testing code you haven't yet written? You think that this is not possible? It
is not only possible, it is the un der ly ing idea of test-dri ven de vel opment. In the extreme
case, you define tests be fore you start coding the actual source code. The program
developer writes an automated test case which defines the desired "behaviour" of a
function. This test case will - that's the idea behind the approach - initially fail, because
the code has still to be written.
Now we have to keep on writing and changing the code for the function fib until it
passes the test.

UNITTEST
296. The Python module unittest is a unit testing framework.

import unittest
from fibonacci import fib
class FibonacciTest(unittest.TestCase):
def testCalculation(self):
self.assertEqual(fib(0), 0)
self.assertEqual(fib(1), 1)
self.assertEqual(fib(5), 5)
self.assertEqual(fib(10), 55)
self.assertEqual(fib(20), 6765)
if __name__ == "__main__":
unittest.main()
If we call this test case, we get the following output:
$ python3 fibonacci_unittest.py
.
--------------------------------------------------
--------------------
Ran 1 test in 0.000s
OK

This is usually the desired result, but we are now interested what happens in the error
case. Therefore we will create our previous error again. We change again the well
known line:
a, b = 0, 1
will be changed in
a, b = 1, 1
Now the test result looks like this:
$ python3 fibonacci_unittest.py
F
==================================================
====================
FAIL: testCalculation (__main__.FibonacciTest)
--------------------------------------------------
--------------------
Traceback (most recent call last):
File "fibonacci_unittest.py", line 7, in
testCalculation
self.assertEqual(fib(0), 0)
AssertionError: 1 != 0
--------------------------------------------------
--------------------
Ran 1 test in 0.000s
FAILED (failures=1)

297.
The doctest is okay. The problem is the implementation of the fibonacci function. This
recursive approach is "highly" inefficient. You need a lot of patience to wait for the
termination of the test. The number of hours, days or weeks depend on your computer.

###########################################################################################
FORMATTED OUTPUT

MANY WAYS FOR A NICER OUTPUT

298.
Since Python 2.6 has been introduced, the string method format should be used instead
of this old-style formatting. Unfortunately, string modulo "%" is still available in
Python3 and what is even worse, it is still widely used. That's why we cover it in great
detail in this tutorial. You should be capable of understanding it, when you encounter it
in some Python code. But it is very likely that one day this old style of formatting will
be removed from the language. So you should get used to str.format().

299.
Examples of positional parameters:
>>> "First argument: {0}, second one:
{1}".format(47,11)
'First argument: 47, second one: 11'
>>> "Second argument: {1}, first one:
{0}".format(47,11)
'Second argument: 11, first one: 47'
>>> "Second argument: {1:3d}, first one:
{0:7.2f}".format(47.42,11)
'Second argument: 11, first one: 47.42'
>>> "First argument: {}, second one:
{}".format(47,11)
'First argument: 47, second one: 11'
>>> # arguments can be used more than once:
...
>>> "various precisions: {0:6.2f} or
{0:6.3f}".format(1.4148)
'various precisions: 1.41 or 1.415'
>>>

300.
In the following example we demonstrate how keyword parameters can be used with
the format method:
>>> "Art: {a:5d}, Price: {p:8.2f}".format(a=453,
p=59.058)
'Art: 453, Price: 59.06'
>>>

301.
It's possible to left or right justify data with the format method. To this end, we can
precede the formatting with a "<" (left justify) or ">" (right justify). We demonstrate
this with the following examples:
>>> "{0:<20s} {1:6.2f}".format('Spam & Eggs:',
6.99)
'Spam & Eggs: 6.99'
>>> "{0:>20s} {1:6.2f}".format('Spam & Eggs:',
6.99)
' Spam & Eggs: 6.99'

302.
Using the position or the index:
>>> print("The capital of {0:s} is
{1:s}".format("Ontario","Toronto"))
The capital of Ontario is Toronto
>>>
Just to mention it once more: We could have used empty curly braces in the
previous example!

303.
Using keyword parameters:
>>> print("The capital of {province} is
{capital}".format(province="Ontario",capital="T
oronto"))
The capital of Ontario is Toronto
>>>
The second case can be expressed with a dictionary as well, as we can see in the
following code:
>>> data =
dict(province="Ontario",capital="Toronto")
>>> data
{'province': 'Ontario', 'capital': 'Toronto'}
>>> print("The capital of {province} is
{capital}".format(**data))
The capital of Ontario is Toronto
The double "*" in front of data turns data automatically into the form
'province="Ontario",capital="Toronto"'. Let's look at the following Python program:
capital_country = {"United States" : "Washington",
"US" : "Washington",
"Canada" : "Ottawa",
"Germany": "Berlin",
"France" : "Paris",
"England" : "London",
"UK" : "London",
"Switzerland" : "Bern",
"Austria" : "Vienna",
"Netherlands" : "Amsterdam"}
print("Countries and their capitals:")
for c in capital_country:
print("{country}: {capital}".format(country=c,
capital=capital_country[c]))

304.
If we start this program, we get the following output:
$ python3 country_capitals.py
Countries and their capitals:
United States: Washington
Canada: Ottawa
Austria: Vienna
Netherlands: Amsterdam
Germany: Berlin
UK: London
Switzerland: Bern
England: London
US: Washington
France: Paris

305.
We can rewrite the previous example by using the dictionary directly. The output will
be the same:
capital_country = {"United States" : "Washington",
"US" : "Washington",
"Canada" : "Ottawa",
"Germany": "Berlin",
"France" : "Paris",
"England" : "London",
"UK" : "London",
"Switzerland" : "Bern",
"Austria" : "Vienna",
"Netherlands" : "Amsterdam"}
print("Countries and their capitals:")
for c in capital_country:
format_string = c + ": {" + c + "}"
print(format_string.format(**capital_country))

306. USING LOCAL VARIABLE NAMES IN "FORMAT"

"locals" is a function, which returns a dictionary with the current scope's local
variables, i.e- the local variable names are the keys of this dictionary and the
corresponding values are the values of these variables:

>>> a = 42
>>> b = 47
>>> def f(): return 42
...
>>> locals()
{'a': 42, 'b': 47, 'f': <function f at
0xb718ca6c>, '__builtins__': <module 'builtins'
(built-in)>, '__package__': None, '__name__':
'__main__', '__doc__': None}
>>>

# OTHER STRING METHODS FOR FORMATTING

307. 
center(...):
S.center(width[, fillchar]) -> str
Return S centred in a string of length width. Padding is done using the specified
fill character. The default value is a space.
Examples:
>>> s = "Python"
>>> s.center(10)
' Python '
>>> s.center(10,"*")
'**Python**'

308.
ljust(...):
S.ljust(width[, fillchar]) -> str
Return S left-justified in a string of length "width". Padding is done using the
specified fill character. If none is given, a space will be used as default.
Examples:
>>> s = "Training"
>>> s.ljust(12)
'Training '
>>> s.ljust(12,":")
'Training::::'
>>>

309.
rjust(...):
S.rjust(width[, fillchar]) -> str
Return S right-justified in a string of length width. Padding is done using the
specified fill character. The default value is again a space.
Examples:

>>> s = "Programming"
>>> s.rjust(15)
' Programming'
>>> s.rjust(15, "~")
'~~~~Programming'
>>>
zfill(...):
S.zfill(width) -> str
Pad a string S with zeros on the left, to fill a field of the specified width. The
string S is never truncated. This method can be easily emulated with rjust.
Examples:
>>> account_number = "43447879"
>>> account_number.zfill(12)
'000043447879'
>>> # can be emulated with rjust:
...
>>> account_number.rjust(12,"0")
'000043447879'
>>>

FORMATTED STRING LITERALS

310.
Python 3.6 introduces formatted string literals. They are prefixed with an 'f'. The
formatting syntax is similar to the format strings accepted by str.format().

>>> price = 11.23
>>> f"Price in Euro: {price}"
'Price in Euro: 11.23'
>>> f"Price in Swiss Franks: {price * 1.086}"
'Price in Swiss Franks: 12.195780000000001'
>>> f"Price in Swiss Franks: {price * 1.086:5.2f}"
'Price in Swiss Franks: 12.20'
>>> for article in ["bread", "butter", "tea"]:
... print(f"{article:>10}:")
...
bread:
butter:
tea:

###########################################################################################
STRUCTURING WITH INDENTATION

311.

Pythangorean Triplets

from math import sqrt
n = input("Maximum Number? ")
n = int(n)+1
for a in range(1,n):
for b in range(a,n):
c_square = a**2 + b**2
c = int(sqrt(c_square))
if ((c_square - c**2) == 0):
print(a, b, c)

###########################################################################################
PARAMETERS AND ARGUMENTS

"CALL BY VALUE" AND "CALL BY NAME"

312.
BY using Call by Reference we save
both computation time and memory space, because arguments do not need to be
copied.

Correctly speaking, Python uses a mechanism, which is known as "Call-by-Object",
sometimes also called "Call by Object Reference" or "Call by Sharing".

313.
>>> def no_side_effects(cities):
... print(cities)
... cities = cities + ["Birmingham",
"Bradford"]
... print(cities)
...
>>> locations = ["London", "Leeds", "Glasgow",
"Sheffield"]
>>> no_side_effects(locations)
['London', 'Leeds', 'Glasgow', 'Sheffield']
['London', 'Leeds', 'Glasgow', 'Sheffield',
'Birmingham', 'Bradford']
>>> print(locations)
['London', 'Leeds', 'Glasgow', 'Sheffield']
>>>

314.
>>> def side_effects(cities):
... print(cities)
... cities += ["Birmingham", "Bradford"]
... print(cities)
...
>>> locations = ["London", "Leeds", "Glasgow",
"Sheffield"]
>>> side_effects(locations)
['London', 'Leeds', 'Glasgow', 'Sheffield']
['London', 'Leeds', 'Glasgow', 'Sheffield',
'Birmingham', 'Bradford']
>>> print(locations)
['London', 'Leeds', 'Glasgow', 'Sheffield',
'Birmingham', 'Bradford']
>>>

We can see that Birmingham and Bradford are included in the global list locations as
well, because += acts as an in-place operation.

315.
The user of this function can prevent this side effect by passing a copy to the function.
A shallow copy is sufficient, because there are no nested structures in the list. To satisfy
our French customers as well, we change the city names in the next example to
demonstrate the effect of the slice operator in the function call:
>>> def side_effects(cities):
... print(cities)
... cities += ["Paris", "Marseille"]
... print(cities)
...
>>> locations = ["Lyon", "Toulouse", "Nice",
"Nantes", "Strasbourg"]
>>> side_effects(locations[:])
['Lyon', 'Toulouse', 'Nice', 'Nantes',
'Strasbourg']
['Lyon', 'Toulouse', 'Nice', 'Nantes',
'Strasbourg', 'Paris', 'Marseille']
>>> print(locations)
['Lyon', 'Toulouse', 'Nice', 'Nantes',
'Strasbourg']
>>>
We can see that the global list locations has not been effected by the execution of the
function.

COMMAND LINE ARGUMENTS
 
316.
The arguments are
separated by spaces. Inside of the script these arguments are accessible through the list
variable sys.argv. The name of the script is included in this list sys.argv[0]. sys.argv[1]
contains the first parameter, sys.argv[2] the second and so on.
The following script (arguments.py) prints all arguments:
# Module sys has to be imported:
import sys
# Iteration over all arguments:
for eachArg in sys.argv:
print(eachArg)
Example call to this script:
python argumente.py python course for beginners
This call creates the following output:
argumente.py
python
course
for
beginners

VARIABLE LENGTH OF PARAMETERS

317. 
EXERCISE
Write a function which calculates the arithmetic mean of a variable number of values.
SOLUTION
def arithmetic_mean(x, *l):
""" The function calculates the arithmetic
mean of a non-empty
arbitrary number of numbers """
sum = x
for i in l:
sum += i
return sum / (1.0 + len(l))

You might ask yourself, why we used both a positional parameter "x" and the variable
parameter "*l" in our function definition. We could have only used *l to contain all our
numbers. The idea is that we wanted to enforce that we always have a non-empty list of
numbers. This is necessary to prevent a division by zero error, because the average of
an empty list of numbers is not defined.

318.
>>> from statistics import arithmetic_mean
>>> arithmetic_mean(4,7,9)
6.666666666666667
>>> arithmetic_mean(4,7,9,45,-3.7,99)
26.71666666666667
This works fine, but there is a catch. What if somebody wants to call the function with a
list, instead of a variable number of numbers, as we have shown above? We can see in
the following that we raise an error, as most hopefully, you might expect:
>>> l = [4,7,9,45,-3.7,99]
>>> arithmetic_mean(l)
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
File "statistics.py", line 8, in arithmetic_mean
return sum / (1.0 + len(l))
TypeError: unsupported operand type(s) for /:
'list' and 'float'
The rescue is using another asterisk:
>>> arithmetic_mean(*l)
26.71666666666667
>>>

319.
* IN FUNCTION CALLS

>>> def f(x,y,z):
... print(x,y,z)
...
>>> p = (47,11,12)
>>> f(*p)
(47, 11, 12)
There is hardly any need to mention that this way of calling our function is more
comfortable than the following one:
>>> f(p[0],p[1],p[2])
(47, 11, 12)
>>>

ARBITRARY KEYWORD PARAMETERS
320. 

>>> def f(**args):
... print(args)
...
>>> f()
{}
>>> f(de="Germnan",en="English",fr="French")
{'fr': 'French', 'de': 'Germnan', 'en': 'English'}
>>>

DOUBLE ASTERISK IN FUNCTION CALLS
321.

>>> def f(a,b,x,y):
... print(a,b,x,y)
...
>>> d = {'a':'append',
'b':'block','x':'extract','y':'yes'}
>>> f(**d)
('append', 'block', 'extract', 'yes')
and now in combination with *:
>>> t = (47,11)
>>> d = {'x':'extract','y':'yes'}
>>> f(*t, **d)
(47, 11, 'extract', 'yes')
>>>

#######################################################################################################
OBJECT-ORIENTED PROGRAMMING

322.
>>> x = 42
>>> type(x)
<class 'int'>
>>> y = 4.34
>>> type(y)
<class 'float'>
>>> def f(x):
... return x + 1
...
>>> type(f)
<class 'function'>
>>> import math
>>> type(math)
<class 'module'>
>>>

323.
The class name is followed
by a listing of other class names, which are classes from which the defined class
inherits from. These classes are called superclasses, base classes or sometimes parent
classes.

class Robot:
pass
if __name__ == "__main__":
x = Robot()
y = Robot()
y2 = y
print(y == y2)
print(y == x)

The output of this example
program looks like this:
True
False

ATTRIBUTES

324.
Attributes are created inside of a class definition, as we will soon learn. We can
dynamically create arbitrary new attributes for existing instances of a class. We do this
by joining an arbitrary name to the instance name, separated by a dot ".". In the
following example, we demonstrate this by created an attribute for the name and the
build year:
>>> class Robot:
... pass
...
>>> x = Robot()
>>> y = Robot()
>>>
>>> x.name = "Marvin"
>>> x.build_year = "1979"
>>>
>>> y.name = "Caliban"
>>> y.build_year = "1993"
>>>
>>> print(x.name)
Marvin
>>> print(y.build_year)
1993
>>>

If you want to know, what's happening internally: The instances possess dictionaries
__dict__, which they use to store their attributes and their corresponding values:
>>> x.__dict__
{'name': 'Marvin', 'build_year': '1979'}
>>> y.__dict__
{'name': 'Caliban', 'build_year': '1993'}

325.
Attributes can be bound to class names as well. In this case, each instance will possess
this name as well. Watch out, what happens, if you assign the same name to an instance:
>>> class Robot(object):
... pass
...
>>> x = Robot()
>>> Robot.brand = "Kuka"
>>> x.brand
'Kuka'
>>> x.brand = "Thales"
>>> Robot.brand
'Kuka'
>>> y = Robot()
>>> y.brand
'Kuka'
>>> Robot.brand = "Thales"
>>> y.brand
'Thales'
>>> x.brand
'Thales'

>>> x.__dict__
{'brand': 'Thales'}
>>> y.__dict__
{}
>>>
>>> Robot.__dict__
mappingproxy({'__module__': '__main__',
'__weakref__': , '__doc__': None, '__dict__': ,
'brand': 'Thales'})

326.
If an attribute name is not in included in either of the dictionary, the attribute name is
not defined. If you try to access a non-existing attribute, you will raise an
AttributeError:
>>> x.energy
Traceback (most recent call last):
File "<stdin>", line 1, in
AttributeError: 'Robot' object has no attribute
'energy'
>>>
By using the function getattr, you can prevent this exception, if you provide a default
value as the third argument:
>>> getattr(x, 'energy', 100)
100
>>>

327.
Binding attributes to objects is a general concept in Python. Even function names can
be attributed. You can bind an attribute to a function name in the same way, we have
done so far to other instances of classes:
>>> def f(x):
... return 42
...
>>> f.x = 42
>>> print(f.x)
42
>>>

This can be used as a replacement for the static function variables of C and C++, which
are not possible in Python. We use a counter attribute in the following example:
def f(x):
f.counter = getattr(f, "counter", 0) + 1
return "Monty Python"
for i in range(10):
f(i)
print(f.counter)

METHODS
328.
The proper way to do it:
Instead of defining a function outside of a class definition and binding it to a class
attribute, we define a method directly inside (indented) of a class definition.
A method is "just" a function which is defined inside of a class.
The first parameter is used a reference to the calling instance.
This parameter is usually called self.
Self corresponds to the Robot object x.

329.
We have seen that a method differs from a function only in two aspects:
It belongs to a class, and it is defined within a class
The first parameter in the definition of a method has to be a reference to the
instance, which called the method. This parameter is usually called "self".

330.
THE __INIT__ METHOD

We want to define the attributes of an instance right after its creation. __init__ is a
method which is immediately and automatically called after an instance has been
created. This name is fixed and it is not possible to chose another name. __init__ is one
of the so-called magic methods, of which we will get to know some more details later.
The __init__ method is used to initialize an instance.

>>> class A:
... def __init__(self):
... print("__init__ has been executed!")
...
>>> x = A()
__init__ has been executed!
>>>

331.
__STR__- AND __REPR__-METHODS

A frequently asked question is when to use __repr__ annd when __str__. __str__ is
always the right choice, if the output should be for the end user or in other words, if it
should be nicely printed. __repr__ on the other hand is used for the internal
representation of an object. The output of __repr__ should be - if feasible - a string
which can be parsed by the python interpreter. The result of this parsing is in an equal
object.
This means that the following should be true for an object "o":
o == eval(repr(o))

332.
>>> l = [3,8,9]
>>> s = repr(l)
>>> s
'[3, 8, 9]'
>>> l == eval(s)
True
>>> l == eval(str(l))
True
>>>

333.
We show in the following example with the datetime module that eval can only be
applied on the strings created by repr:
>>> import datetime
>>> today = datetime.datetime.now()
>>> str_s = str(today)
>>> eval(str_s)
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
File "<string>", line 1
2014-01-26 17:35:39.215144
^
SyntaxError: invalid token
>>> repr_s = repr(today)
>>> t = eval(repr_s)
>>> type(t)
<class 'datetime.datetime'>
>>>

334.
class Robot:
def __init__(self, name, build_year):
self.name = name
self.build_year = build_year
def __repr__(self):
return "Robot('" + self.name + "', " +
str(self.build_year) + ")"
if __name__ == "__main__":
x = Robot("Marvin", 1979)
x_str = str(x)
print(x_str)
print("Type of x_str: ", type(x_str))
new = eval(x_str)
print(new)
print("Type of new:", type(new))
x_str has the value Robot('Marvin', 1979). eval(x_str) converts it again into a Robot
instance.
The script returns the following output:
$ python3 robot_class5.py
Robot("Marvin",1979)
Type of x_str: <class 'str'>
Robot("Marvin",1979)
Type of new: <class '__main__.Robot'>

class Robot:
def __init__(self, name, build_year):
self.name = name
self.build_year = build_year
def __repr__(self):
return "Robot('" + self.name + "', " +
str(self.build_year) + ")"
def __str__(self):
return "Name: " + self.name + ", Build
Year: " + str(self.build_year)
if __name__ == "__main__":
x = Robot("Marvin", 1979)
x_str = str(x)
print(x_str)
print("Type of x_str: ", type(x_str))
new = eval(x_str)
print(new)
print("Type of new:", type(new))

$ python3 robot_class6.py
Name: Marvin, Build Year: 1979
Type of x_str: <class 'str'>

Traceback (most recent call last):
File "robot_class6.py", line 19, in <module>
new = eval(x_str)
File "<string>", line 1
Name: Marvin, Build Year: 1979
^
SyntaxError: invalid syntax

We show in the following program that x_repr can still be turned into a Robot object:
class Robot:
def __init__(self, name, build_year):
self.name = name
self.build_year = build_year
def __repr__(self):
return "Robot(\"" + self.name + "\"," +
str(self.build_year) + ")"
def __str__(self):
return "Name: " + self.name + ", Build
Year: " + str(self.build_year)
if __name__ == "__main__":
x = Robot("Marvin", 1979)
x_repr = repr(x)
print(x_repr, type(x_repr))
new = eval(x_repr)
print(new)
print("Type of new:", type(new))

The output looks like this:
$ python3 robot_class6b.py
Robot("Marvin",1979) <class 'str'>
Name: Marvin, Build Year: 1979
Type of new: <class '__main__.Robot'>

335.
To summarize the attribute types:
Naming Type Meaning
name Public These attributes can be freely used inside or outside of a class
definition.
_name Protected Protected attributes should not be used outside of the class
definition, unless inside of a subclass definition.
__name Private This kind of attribute is inaccessible and invisible. It's neither
possible to read nor write to those attributes, except inside of the
class definition itself.

336.
class A():
def __init__(self):
self.__priv = "I am private"
self._prot = "I am protected"
self.pub = "I am public"
We store this class (attribute_tests.py) and test its behaviour in the following interactive
Python shell:
>>> from attribute_tests import A
>>> x = A()
>>> x.pub
'I am public'
>>> x.pub = x.pub + " and my value can be changed"
>>> x.pub
'I am public and my value can be changed'
>>> x._prot
'I am protected'
>>> x.__priv
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
AttributeError: 'A' object has no attribute
'__priv'
>>>

337.
class Robot:
def __init__(self, name=None,
build_year=2000):
self.__name = name
self.__build_year = build_year
def say_hi(self):
if self.__name:
print("Hi, I am " + self.__name)
else:
print("Hi, I am a robot without a
name")
def set_name(self, name):
self.__name = name
def get_name(self):
return self.__name
def set_build_year(self, by):
self.__build_year = by
def get_build_year(self):
return self.__build_year
def __repr__(self):
return "Robot('" + self.__name + "', " +
str(self.__build_year) + ")"
def __str__(self):
return "Name: " + self.__name + ", Build
Year: " + str(self.__build_year)
if __name__ == "__main__":
x = Robot("Marvin", 1979)
y = Robot("Caliban", 1943)
for rob in [x, y]:
rob.say_hi()
if rob.get_name() == "Caliban":
rob.set_build_year(1993)
print("I was built in the year " +
str(rob.get_build_year()) + "!")

Hi, I am Marvin
I was built in the year 1979!
Hi, I am Caliban
I was built in the year 1993!

Every private attribute of our class has a getter and a setter.

DESTRUCTOR

338. There is no "real"
destructor, but something similar, i.e. the method __del__.

339.
There is a way to access a private attribute directly. In our example, we can do it like
this: x._Robot__build_year
You shouldn't do this under any circumstances!

340.
The usage of the __del__method is very problematic.

The following script is an example with __init__ and __del__:
class Robot():
def __init__(self, name):
print(name + " has been created!")
def __del__(self):
print ("Robot has been destroyed")
if __name__ == "__main__":
x = Robot("Tik-Tok")
y = Robot("Jenkins")
z = x
print("Deleting x")
del x
print("Deleting z")
del z
del y
The output of the previous program:
$ python3 del_example.py
Tik-Tok has been created!
Jenkins has been created!
Deleting x
Deleting z
Robot has been destroyed
Robot has been destroyed

#######################################################################################################
NAMESPACES AND SCOPES

341.
Some namespaces in Python:
global names of a module
local names in a function or method invocation
built-in names: this namespace contains built-in fuctions (e.g. abs(), cmp(), ...)
and built-in exception names.

342. 
Namespaces have different lifetimes,
because they are often created at different points in time. There is one namespace which
is present from beginning to end: The namespace containing the built-in names is
created when the Python interpreter starts up, and is never deleted. The global
namespace of a module is generated when the module is read in. Module namespaces
normally last until the script ends, i.e. the interpreter quits. When a function is called, a
local namespace is created for this function. This namespace is deleted either if the
function ends, i.e. returns, or if the function raises an exception, which is not dealt with
within the function.

#######################################################################################################
GENERATORS

343. An iterator can be seen as a pointer to a
container, e.g. a list structure that can
iterate over all the elements of this
container.

344. Generators are a special kind of function, which enable us to implement or generate
iterators.

345. We are iterating over a list, but you shouldn't be mistaken: A
list is not an iterator, but it can be used like an iterator:

346. 
What is really happening, when you use an iterable like a string, a list, or a tuple, inside
of a for loop is the following: The function "iter" is called on the iterable. The return
value of iter is an iterable. We can iterate over this iterable with the next function until
the iterable is exhausted and returns a StopIteration exception:
>>> expertises = ["Novice", "Beginner",
"Intermediate", "Proficient", "Experienced",
"Advanced"]
>>> expertises_iterator = iter(expertises)
>>> next(expertises_iterator)
'Novice'
>>> next(expertises_iterator)
'Beginner'
>>> next(expertises_iterator)
'Intermediate'
>>> next(expertises_iterator)
'Proficient'
>>> next(expertises_iterator)
'Experienced'
>>> next(expertises_iterator)
'Advanced'
>>> next(expertises_iterator)
Traceback (most recent call last):
File "", line 1, in
StopIteration
Internally, the for loop also calls the next function and terminates, when it gets
StopIteration.

347.
other_cities = ["Strasbourg", "Freiburg",
"Stuttgart",
"Vienna / Wien", "Hannover",
"Berlin",
"Zurich"]
city_iterator = iter(other_cities)
while city_iterator:
try:
city = next(city_iterator)
print(city)
except StopIteration:
break

348.
The
yield statement turns a functions into a generator. A generator is a function which
returns a generator object. This generator object can be seen like a function which
produces a sequence of results instead of a single object. This sequence of values is
produced by iterating over it, e.g. with a for loop.

349. 
As soon as "next" is called again on the generator
object, the generator function will resume execution right after the yield statement in
the code, where the last call exited. The execution will continue in the state in which the
generator was left after the last yield.

350.
Can we send a reset to an iterator is a frequently asked question, so that it can start the
iteration all over again. There is no reset, but it's possible to create another generator.
This can be done e.g. by having the statement "x = city_generator()" again.

351.
Method of working:
A generator is called like a function. Its return value is an iterator, i.e. a generator
object. The code of the generator will not be executed at this stage.
The iterator can be used by calling the next method. The first time the execution
starts like a function, i.e. the first line of code within the body of the iterator. The
code is executed until a yield statement is reached.
yield returns the value of the expression, which is following the keyword yield.
This is like a function, but Python keeps track of the position of this yield and the
state of the local variables is stored for the next call. At the next call, the
execution continues with the statement following the yield statement and the
variables have the same values as they had in the previous call.
The iterator is finished, if the generator body is completely worked through or if
the program flow encounters a return statement without a value.

352.

def fibonacci(n):
""" A generator for creating the Fibonacci
numbers """
a, b, counter = 0, 1, 0
while True:
if (counter > n):
return
yield a
a, b = b, a + b
counter += 1
f = fibonacci(5)
for x in f:
print(x, " ", end="") #
print()

353.
We have to take care when we use this iterator that a termination criterion is
used:
def fibonacci():
"""Generates an infinite sequence of Fibonacci
numbers on demand"""
a, b = 0, 1
while True:
yield a
a, b = b, a + b
f = fibonacci()
counter = 0
for x in f:
print(x, " ", end="")
counter += 1
if (counter > 10):
break
print()

354.
A return statement inside of a generator is
equivalent to raise StopIteration()

355.

>>> def gen():
... yield 1
... return 42
...
>>>
>>> g = gen()
>>> next(g)
1
>>> next(g)
Traceback (most recent call last):
File "", line 1, in
StopIteration: 42
>>>

356.
SEND METHOD /COROUTINES
Generators can not only send objects but also receive objects. Sending a message, i.e.
an object, into the generator can be achieved by applying the send method to the
generator object.

>>> def simple_coroutine():
... print("coroutine has been started!")
... x = yield
... print("coroutine received: ", x)
...
>>> cr = simple_coroutine()
>>> cr
>>> next(cr)
coroutine has been started!
>>> cr.send("Hi")
coroutine received: Hi
Traceback (most recent call last):
File "", line 1, in
StopIteration
>>>

357.
We had to call next on the generator first, because the generator needed to be started.
Using send to a generator which hasn't been started leads to an exception:
>>> cr = simple_coroutine()
>>> cr.send("Hi")
Traceback (most recent call last):
File "", line 1, in
TypeError: can't send non-None value to a juststarted
generator
>>>

358.
def infinite_looper(objects):
count = 0
while True:
if count >= len(objects):
count = 0
message = yield objects[count]
if message != None:
count = 0 if message < 0 else message
else:
count += 1
We demonstrate how to use this generator in the following interactive session, assuming
that the generator is saved in a file called generator_decorator.py:
>>> x = infinite_looper("A string with some
words")
>>> next(x)
'A'
>>> x.send(9)
'w'
>>> x.send(10)
'i'
>>>

THE THROW METHOD

359.
The throw() method raises an exception at the point where the generator was paused,
and returns the next value yielded by the generator. It raises StopIteration if the
generator exits without yielding another value.

def infinite_looper(objects):
count = 0
while True:
if count >= len(objects):
count = 0
try:
message = yield objects[count]
except Exception:
print("index: " + str(count))
if message != None:
count = 0 if message < 0 else message
else:
count += 1

We can use it like this:
>>> from generator_throw import infinite_looper
>>> looper = infinite_looper("Python")
>>> next(looper)
'P'
>>> next(looper)
'y'
>>> looper.throw(Exception)
index: 1
't'
>>> next(looper)
'h'

360.
class StateOfGenerator(Exception):
def __init__(self, message=None):
self.message = message
def infinite_looper(objects):
count = 0
while True:
if count >= len(objects):
count = 0
try:
message = yield objects[count]
except StateOfGenerator:
print("index: " + str(count))
if message != None:
count = 0 if message < 0 else message
else:
count += 1

We can use the previous generator like this:
>>> from generator_throw import infinite_looper,
StateOfGenerator
>>> looper = infinite_looper("Python")
>>> next(looper)
'P'
>>> next(looper)
'y'
>>> looper.throw(StateOfGenerator)
index: 1
't'
>>> next(looper)
'h'
>>>

361. DECORATING GENERATORS

from functools import wraps
def get_ready(gen):
"""
Decorator: gets a generator gen ready
by advancing to first yield statement
"""
@wraps(gen)
def generator(*args,**kwargs):
g = gen(*args,**kwargs)
next(g)
return g
return generator
@get_ready
def infinite_looper(objects):
count = -1
message = yield None
while True:
count += 1
if message != None:
count = 0 if message < 0 else message
if count >= len(objects):
count = 0
message = yield objects[count]
x = infinite_looper("abcdef")
print(next(x))
print(x.send(4))
print(next(x))
print(next(x))
print(x.send(5))
print(next(x))
This program returns the following results:
a
e
f
a
f
a

362. YIELD FROM

"yield from" is available since Python 3.3!
The yield from <expr> statement can be used inside the body of a generator. <expr> has
to be an expression evaluating to an iterable, from which an iterator will be extracted.
The iterator is run to exhaustion, i.e. until it encounters a StopIteration exception. This
iterator yields and receives values to or from the caller of the generator, i.e. the one
which contains the yield from statement.

def gen1():
for char in "Python":
yield char
for i in range(5):
yield i
def gen2():
yield from "Python"
yield from range(5)
g1 = gen1()
g2 = gen2()
print("g1: ", end=", ")
for x in g1:
print(x, end=", ")
print("\ng2: ", end=", ")
for x in g2:
print(x, end=", ")
print()

g1: , P, y, t, h, o, n, 0, 1, 2, 3, 4,
g2: , P, y, t, h, o, n, 0, 1, 2, 3, 4,

363.
def subgenerator():
yield 1
return 42
def delegating_generator():
x = yield from subgenerator()
print(x)
for x in delegating_generator():
print(x)
The above code returns the following code:
1
42

364.
The full semantics of the yield from expression is described in six points in "PEP 380 -
- Syntax for Delegating to a Subgenerator" in terms of the generator protocol:

- Any values that the iterator yields are passed directly to the caller.
- Any values sent to the delegating generator using send() are passed directly to the
  iterator. If the sent value is None, the iterator's __next__() method is called. If the
  sent value is not None, the iterator's send() method is called. If the call raises
  StopIteration, the delegating generator is resumed. Any other exception is
  propagated to the delegating generator.
- Exceptions other than GeneratorExit thrown into the delegating generator are
  passed to the throw() method of the iterator. If the call raises StopIteration, the
  delegating generator is resumed. Any other exception is propagated to the
  delegating generator.
- If a GeneratorExit exception is thrown into the delegating generator, or the
  close() method of the delegating generator is called, then the close() method of
  the iterator is called if it has one. If this call results in an exception, it is
  propagated to the delegating generator. Otherwise, GeneratorExit is raised in the
  delegating generator.
- The value of the yield from expression is the first argument to the StopIteration
  exception raised by the iterator when it terminates.
- return expr in a generator causes StopIteration(expr) to be raised upon exit
  from the generator.
  
RECURSIVE GENERATORS
 
365.

M1

The permutation generator can be called with an arbitrary list of objects. The iterator
returned by this generator generates all the possible permutations:
def permutations(items):
n = len(items)
if n==0: yield []
else:
for i in range(len(items)):
for cc in
permutations(items[:i]+items[i+1:]):
yield [items[i]]+cc
for p in permutations(['r','e','d']):
print(''.join(p))
for p in permutations(list("game")):
print(''.join(p) + ", ", end="")

M2

Creating permutations with itertools:
>>> import itertools
>>> perms = itertools.permutations(['r','e','d'])
>>> perms
<itertools.permutations object at 0x7fb0da3e4a70>
>>> list(perms)
[('r', 'e', 'd'), ('r', 'd', 'e'), ('e', 'r',
'd'), ('e', 'd', 'r'), ('d', 'r', 'e'), ('d', 'e',
'r')]
>>>

366.
A generator for the creation of k-permuations of n objects looks very similar to our
previous permutations generator:
def k_permutations(items, n):
if n==0:
yield []
else:
for item in items:
for kp in k_permutations(items, n-1):
if item not in kp:
yield [item] + kp
for kp in k_permutations("abcd", 3):
print(kp)

A GENERATOR OF GENERATORS

367.

The second generator of our Fibonacci sequence example generates an iterator, which
can theoretically produce all the Fibonacci numbers, i.e. an infinite number. But you
shouldn't try to produce all these numbers, as we would do in the following example:
list(fibonacci())
This will show you very fast the limits of your computer.

368.
The following script returns the first 10 elements of the Fibonacci sequence:
#!/usr/bin/env python3
def fibonacci():
"""Ein Fibonacci-Zahlen-Generator"""
a, b = 0, 1
while True:
yield a
a, b = b, a + b
def firstn(g, n):
for i in range(n):
yield next(g)
print(list(firstn(fibonacci(), 10)))
The output looks like this:
[0, 1, 1, 2, 3, 5, 8, 13, 21, 34]

369.
EXERCISES
1. Write a generator which computes the running average.

2. Write a generator "trange", which generates a sequence of time tuples from start
to stop incremented by step. A time tuple is a 3-tuple of integers: (hours, minutes,
seconds)
Example:
for time in trange((10, 10, 10), (13, 50, 15),
(0, 15, 12) ):
print(time)
will return
(10, 10, 10)
(10, 25, 22)
(10, 40, 34)
(10, 55, 46)
(11, 10, 58)
(11, 26, 10)
(11, 41, 22)
(11, 56, 34)
(12, 11, 46)
(12, 26, 58)
(12, 42, 10)
(12, 57, 22)
(13, 12, 34)
(13, 27, 46)
(13, 42, 58)

3. Write a version "rtrange" of the previous generator, which can receive message to
reset the start value.

4. Write a program, using the newly written generator "trange", to create a file
"times_and_temperatures.txt". The lines of this file contain a time in the format
hh::mm::ss and random temperatures between 10.0 and 25.0 degrees. The times
should be ascending in steps of 90 seconds starting with 6:00:00.
For example:
06:00:00 20.1
06:01:30 16.1
06:03:00 16.9
06:04:30 13.4
06:06:00 23.7
06:07:30 23.6
06:09:00 17.5
06:10:30 11.0

5. Write a generator with the name
"random_ones_and_zeroes", which returns a
bitstream, i.e. a zero or a one in every iteration.
The probability p for returning a 1 is defined in a
variable p. The generator will initialize this value
to 0.5. This means that zeroes and ones will be
returned with the same probability.

370. If you want to develop programs which are readable, reliable and maintainable without
too much effort, you have to use some kind of modular software design. Especially if
your application has a certain size.

############################################################################################################
MODULAR PROGRAMMING AND MODULES

371. Modular programming is a software design technique to split your
code into separate parts. These parts are called modules. The focus for this separation
should be to have modules with no or just few dependencies upon other modules. In
other words: Minimization of dependencies is the goal.

372. When creating a modular
system, several modules are built separately and more or less independently. The
executable application will be created by putting them together.

373. So far we haven't explained what a Python module is. To put it in a nutshell: every file,
which has the file extension .py and consists of proper Python code, can be seen or is a
module! There is no special syntax required to make such a file a module.

374. It's not recommended to use the asterisk notation in an import statement, except when
working in the interactive Python shell.

375. The module name is moulded out of the file name by
removing the suffix .py. For example, if the file name is fibonacci.py, the module name
is fibonacci.

376. As you can easily imagine: It's a pain if you have to use those functions often in your
program and you always have to type in the fully qualified name, i.e. fibonacci.fib(7).
One solution consists in assigning a local name to a module function to get a shorter
name:
>>> fib = fibonacci.ifib
>>> fib(10)
55
>>>

377. We save with the name "one_time.py" and import it two times in an interactive session:
>>> import one_time
The module is imported now!
>>> import one_time
>>>
We can see that it was only imported once. Each module can only be imported once per
interpreter session or in a program or script. If you change a module and if you want to
reload it, you must restart the interpreter again.

378. Since version 3.4 you should use the "importlib" module, because imp.reload is marked
as deprecated:
>>> from importlib import reload
>>> import one_time
The module is imported now!
>>> reload(one_time)
The module is imported now!
>>>

379. Global variables of a module can be accessed with the same notation as functions, i.e.
modname.name

380. A module can import other modules. It is customary to place all import statements at
the beginning of a module or a script.

IMPORTING NAMES FROM A MODULE DIRECTLY

381. Essentially a Python module is a script, so it can be run as a script:
python fibo.py
The module which has been started as a script will be executed as if it had been
imported, but with one exception: The system variable __name__ is set to "__main__".
So it's possible to program different behaviour into a module for the two cases. With the
following conditional statement the file can be used as a module or as a script, but only
if it is run as a script the method fib will be started with a command line argument:
if __name__ == "__main__":
import sys
fib(int(sys.argv[1]))
If it is run as a script, we get the following output:
$ python fibo.py 50
1 1 2 3 5 8 13 21 34
If it is imported, the code in the if block will not be executed:
>>> import fibo
>>>

MODULE SEARCH PATH

382.
If you import a module, let's say "import xyz", the interpreter searches for this module
in the following locations and in the order given:
1. The directory of the top-level file, i.e. the file being executed.
2. The directories of PYTHONPATH, if this global environment variable of your
operating system is set.
3. standard installation path Linux/Unix e.g. in /usr/lib/python3.5.

383.
It's possible to find out where a module is located after it has been imported:
>>> import numpy
>>> numpy.__file__
'/usr/lib/python3/dist-packages/numpy/__init__.py'
>>>
>>> import random
>>> random.__file__
'/usr/lib/python3.5/random.py'
>>>

The __file__ attribute doesn't always exists. This is the case with modules which are
statically linked C libraries.
>>> import math
>>> math.__file__
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
AttributeError: 'module' object has no attribute
'__file__'
>>>

CONTENT OF A MODULE
384. 
With the built-in function dir() and the name of the module as an argument, you can list
all valid attributes and methods for that module.

385.
It's possible to get a list of the Built-in functions, exceptions, and other objects by
importing the builtins module:
>>> import builtins
>>> dir(builtins)
['ArithmeticError', 'AssertionError',
'AttributeError', 'BaseException',
'BlockingIOError', 'BrokenPipeError',
'BufferError', 'BytesWarning',

############################################################################################################
ON THE ROAD TO META CLASSES

386. 
class Philosopher1:
def the_answer(self, *args):
return 42
class Philosopher2:
def the_answer(self, *args):
return 42
class Philosopher3:
def the_answer(self, *args):
return 42
plato = Philosopher1()
print(plato.the_answer())
kant = Philosopher2()
# let's see what Kant has to say :-)
print(kant.the_answer())
42
42

Making above code better below :
-----------------------------------------------------------


Each Philosopher class inherits now from this base class:
class Answers:
def the_answer(self, *args):
return 42
class Philosopher1(Answers):
pass
class Philosopher2(Answers):
pass
class Philosopher3(Answers):
pass
plato = Philosopher1()
print(plato.the_answer())
kant = Philosopher2()
# let's see what Kant has to say :-)
print(kant.the_answer())
42
42

Making above code to be used at run-time :
-----------------------------------------------------------

# the following variable would be set as the
result of a runtime calculation:
x = input("Do you need the answer? (y/n): ")
if x=="y":
required = True
else:
required = False
def the_answer(self, *args):
return 42
class Philosopher1:
pass
if required:
Philosopher1.the_answer = the_answer
class Philosopher2:
pass
if required:
Philosopher2.the_answer = the_answer
class Philosopher3:
pass
if required:
Philosopher3.the_answer = the_answer
plato = Philosopher1()
kant = Philosopher2()

# let's see what Plato and Kant have to say :-)
if required:
print(kant.the_answer())
print(plato.the_answer())
else:
print("The silence of the philosphers")
Do you need the answer? (y/n): y
42
42

We can improve our approach by defining a manager function and avoiding redundant
code this way. The manager function will be used to augment the classes conditionally.
-----------------------------------------------------------
# the following variable would be set as the
result of a runtime calculation:
x = input("Do you need the answer? (y/n): ")
if x=="y":
required = True
else:
required = False
def the_answer(self, *args):
return 42
# manager function
def augment_answer(cls):
if required:
cls.the_answer = the_answer
class Philosopher1:
pass
augment_answer(Philosopher1)
class Philosopher2:
pass
augment_answer(Philosopher2)
class Philosopher3:
pass
augment_answer(Philosopher3)
plato = Philosopher1()
kant = Philosopher2()
# let's see what Plato and Kant have to say :-)
if required:
print(kant.the_answer())
print(plato.the_answer())
else:
print("The silence of the philosphers")
Do you need the answer? (y/n): y
42
42

We need a way to make sure that "some" code might be
executed automatically after the end of a class definition.
-----------------------------------------------------------
# the following variable would be set as the
result of a runtime calculation:
x = input("Do you need the answer? (y/n): ")
if x=="y":
required = True
else:
required = False
def the_answer(self, *args):
return 42
def augment_answer(cls):
if required:
cls.the_answer = the_answer
# we have to return the class now:
return cls
@augment_answer
class Philosopher1:
pass
@augment_answer
class Philosopher2:
pass
@augment_answer
class Philosopher3:
pass
plato = Philosopher1()
kant = Philosopher2()
# let's see what Plato and Kant have to say :-)
if required:
print(kant.the_answer())
print(plato.the_answer())
else:
print("The silence of the philosphers")
Do you need the answer? (y/n): y
42
42
Metaclasses can also be used for this purpose as we will learn in the next chapter.

############################################################################################################
MULTIPLE INHERITANCE

387. 
Multiple inheritance on the other
hand is a feature in which a class can inherit attributes
and methods from more than one parent class.

388.
The widespread prejudice that multiple inheritance is something "dangerous" or "bad"
is mostly nourished by programming languages with poorly implemented multiple
inheritance mechanisms and above all by improper usage of it. Java doesn't even
support multiple inheritance, while C++ supports it. Python has a sophisticated and
well-designed approach to multiple inheritance.

389.
"""
The class Calendar implements a calendar.
"""
class Calendar(object):
months = (31,28,31,30,31,30,31,31,30,31,30,31)
date_style = "British"
@staticmethod
def leapyear(year):
"""
The method leapyear returns True if the
parameter year
is a leap year, False otherwise
"""
if not year % 4 == 0:
return False
elif not year % 100 == 0:
return True
elif not year % 400 == 0:
return False
else:
return True
def __init__(self, d, m, y):
"""
d, m, y have to be integer values and year
has to be
a four digit year number
"""
self.set_Calendar(d,m,y)
def set_Calendar(self, d, m, y):
"""
d, m, y have to be integer values and year
has to be
a four digit year number
"""
if type(d) == int and type(m) == int and
type(y) == int:
self.__days = d
self.__months = m
self.__years = y
else:
raise TypeError("d, m, y have to be
integers!")
def __str__(self):
if Calendar.date_style == "British":
return "
{0:02d}/{1:02d}/{2:4d}".format(self.__days,
self.__months,
self.__years)
else:
# assuming American style
return "
{0:02d}/{1:02d}/{2:4d}".format(self.__months,
self.__days,
self.__years)
def advance(self):
"""
This method advances to the next date.
"""
max_days = Calendar.months[self.__months-
1]
if self.__months == 2 and
Calendar.leapyear(self.__years):
max_days += 1
if self.__days == max_days:
self.__days= 1
if self.__months == 12:
self.__months = 1
self.__years += 1
else:
self.__months += 1
else:
self.__days += 1
if __name__ == "__main__":
x = Calendar(31,12,2012)
print(x, end=" ")
x.advance()
print("after applying advance: ", x)
print("2012 was a leapyear:")
x = Calendar(28,2,2012)
print(x, end=" ")
x.advance()
print("after applying advance: ", x)
x = Calendar(28,2,2013)
print(x, end=" ")
x.advance()
print("after applying advance: ", x)
print("1900 no leapyear: number divisible by
100 but not by 400: ")
x = Calendar(28,2,1900)
print(x, end=" ")
x.advance()
print("after applying advance: ", x)
print("2000 was a leapyear, because number
divisibe by 400: ")
x = Calendar(28,2,2000)
print(x, end=" ")
x.advance()
print("after applying advance: ", x)
print("Switching to American date style: ")
Calendar.date_style = "American"
print("after applying advance: ", x)

$ python3 calendar.py
31.12.2012 after applying advance: 01.01.2013
2012 was a leapyear:
28.02.2012 after applying advance: 29.02.2012
28.02.2013 after applying advance: 01.03.2013
1900 no leapyear: number divisible by 100 but not
by 400:
28.02.1900 after applying advance: 01.03.1900
2000 was a leapyear, because number divisibe by
400:
28.02.2000 after applying advance: 29.02.2000
Switching to American date style:
after applying advance: 02/29/2000

"""
Modul, which implements the class CalendarClock.
"""
from clock import Clock
from calendar import Calendar
class CalendarClock(Clock, Calendar):
"""
The class CalendarClock implements a clock
with integrated calendar. It's a case of multiple
inheritance, as it inherits
both from Clock and Calendar
"""
def __init__(self,day, month, year, hour,
minute, second):
Clock.__init__(self,hour, minute, second)
Calendar.__init__(self,day, month, year)
def tick(self):
"""
advance the clock by one second
"""
previous_hour = self._hours
Clock.tick(self)
if (self._hours < previous_hour):
self.advance()
def __str__(self):
return Calendar.__str__(self) + ", " +
Clock.__str__(self)
if __name__ == "__main__":
x = CalendarClock(31,12,2013,23,59,59)
print("One tick from ",x, end=" ")
x.tick()
print("to ", x)
x = CalendarClock(28,2,1900,23,59,59)
print("One tick from ",x, end=" ")
x.tick()
print("to ", x)

x = CalendarClock(28,2,2000,23,59,59)
print("One tick from ",x, end=" ")
x.tick()
print("to ", x)
x = CalendarClock(7,2,2013,13,55,40)
print("One tick from ",x, end=" ")
x.tick()
print("to ", x)

The output of the program hopefully further clarifies what's going on in this class:
$ python3 calendar_clock.py
One tick from 31/12/2013, 23:59:59 to
01/01/2014, 00:00:00
One tick from 28/02/1900, 23:59:59 to
01/03/1900, 00:00:00
One tick from 28/02/2000, 23:59:59 to
29/02/2000, 00:00:00
One tick from 07/02/2013, 13:55:40 to
07/02/2013, 13:55:41


THE DIAMOND PROBLEM OR THE ,,DEADLY DIAMOND OF DEATH''

390.
class A:
def m(self):
print("m of A
called")
class B(A):
def m(self):
print("m of B
called")
class C(A):
def m(self):
print("m of C called")
class D(B,C):
pass
If you call the method m on an instance x of D, i.e. x.m(), we will get the output "m of
B called". If we transpose the order of the classes in the class header of D in "class
D(C,B):", we will get the output "m of C called".

391.
The case in which m will be overridden only in one of the classes B or C, e.g. in C:
class A:
def m(self):
print("m of A called")
class B(A):
pass
class C(A):
def m(self):
print("m of C called")
class D(B,C):
pass
x = D()
x.m()
Principially, two possibilities are imaginable: "m of C" or "m of A" could be used
We call this script with Python2.7 (python) and with Python3 (python3) to see what's
happening:
$ python diamond1.py
m of A called
$ python3 diamond1.py
m of C called

##################################################
SUPER AND MRO
392. 

MRO "Method Resolution Order"

class A:
def m(self):
print("m of A called")
class B(A):
def _m(self):
print("m of B called")
def m(self):
self._m()
A.m(self)
class C(A):
def _m(self):
print("m of C called")
def m(self):
self._m()
A.m(self)
class D(B,C):
def m(self):
print("m of D called")
B._m(self)
C._m(self)
A.m(self)
Our problem is solved, but - as we have already mentioned - not in a pythonic way:
>>> from super4 import D
>>> x = D()
>>> x.m()
m of D called
m of B called
m of C called
m of A called
The optimal way to solve the problem, which is the "super" pythonic way, consists in
calling the super function:
class A:
def m(self):
print("m of A called")
class B(A):
def m(self):
print("m of B called")
super().m()
class C(A):
def m(self):
print("m of C called")
super().m()
class D(B,C):
def m(self):
print("m of D called")
super().m()
It also solves our problem, but in a beautiful design as well:
>>> from super5 import D
>>> x = D()
>>> x.m()
m of D called
m of B called
m of C called
m of A called
The super function is often used when instances are initialized with the __init__
method:
class A:
def __init__(self):
print("A.__init__")
class B(A):
def __init__(self):
print("B.__init__")
super().__init__()
class C(A):
def __init__(self):
print("C.__init__")
super().__init__()
class D(B,C):
def __init__(self):
print("D.__init__")
super().__init__()
We demonstrate the way of working in the following interactive session:
>>> from super_init import A,B,C,D
>>> d = D()
D.__init__
B.__init__
C.__init__
A.__init__
>>> c = C()
C.__init__
A.__init__
>>> b = B()
B.__init__
A.__init__
>>> a = A()
A.__init__
The question arises how the super functions makes its decision. How does it decide
which class has to be used? As we have already mentioned, it uses the so-called method
resolution order(MRO). It is based on the "C3 superclass linearisation" algorithm. This
is called a linearisation, because the tree structure is broken down into a linear order.
The mro method can be used to create this list:
>>> from super_init import A,B,C,D
>>> D.mro()
[<class 'super_init.D'>, <class 'super_init.B'>,
<class 'super_init.C'>, <class 'super_init.A'>,
<class 'object'>]
>>> B.mro()
[<class 'super_init.B'>, <class 'super_init.A'>,
<class 'object'>]
>>> A.mro()
[<class 'super_init.A'>, <class 'object'>]

#########################################################
POLYMORPHISM

393.
Python is implicitly polymorphic. We can apply our previously defined function f even
to lists, strings or other types, which can be printed:
>>> def f(x,y):
... print("values: ", x, y)
...
>>> f([3,5,6],(3,5))
values: [3, 5, 6] (3, 5)
>>> f("A String", ("A tuple", "with Strings"))
values: A String ('A tuple', 'with Strings')
>>> f({2,3,9}, {"a":3.4,"b":7.8, "c":9.04})
values: {9, 2, 3} {'a': 3.4, 'c': 9.04, 'b': 7.8}
>>>
############################################################################################################

PYTHON ESSENTIAL TRAINING
https://www.linkedin.com/learning/python-essential-training-2/exercise-files

1.
>>> import this
The Zen of Python, by Tim Peters

Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
Flat is better than nested.
Sparse is better than dense.
Readability counts.
Special cases aren't special enough to break the rules.
Although practicality beats purity.
Errors should never pass silently.
Unless explicitly silenced.
In the face of ambiguity, refuse the temptation to guess.
There should be one-- and preferably only one --obvious way to do it.
Although that way may not be obvious at first unless you're Dutch.
Now is better than never.
Although never is often better than *right* now.
If the implementation is hard to explain, it's a bad idea.
If the implementation is easy to explain, it may be a good idea.
Namespaces are one honking great idea -- let's do more of those!
>>> 

2. Everything is an object.

3. print is a function.

4. All text is now unicode.

5. Question 2 of 2
Why should you select UTF-8 as the default editor encoding?

You are correct!
so it can match the Unicode standard of Python 3

6. Shebang line

7.  So type is a built-in function that prints the type of a value or variable.
And so when I save and run this you'll notice that it says that the type is class 'int'.
That's the integer type. It's one of the built-in types.
Python uses a form of dynamic typing sometimes called duck typing where the type of a value
is determined by the value itself. In other words, if it walks like a duck, it's a duck.
So if I change this value to say 7.0 and I save and run it, you see now it's class 'float'.
So it's a floating point number.

8. In Python 3, all types are classes, even the built-in types.

9.  There is no difference between single quotes and double quotes in Python.
In some languages double quotes are interpolated, single quotes are not, or
there may be other distinctions. In Python, there is no difference whatsoever.
In fact, you can even do it this way. You can use three single quotes.
And if I save and run you'll see there's no difference. What that allows you to do,
though, is to put things on several lines. So, using three quotes you can actually make
a multi-line string. And if I save and run this, you see that the result here, and I'll
open this up, says x is seven with lots of newlines and before and after it. And those single
quotes can be double quotes as well. So, you'll often see this. These triple quotes are usually
made out of double quotes, I know that seems to be the style that most often people use. So,
if I save and run this, you see our result is still the same. But for now, we're going to go
right back to my style choice. And again, it's good to have a default style and stick to it.
For my part, I tend to use the single quotes. 

10. 
a = 8
b = 9
x = f'seven {a} {b}'
print('x is {}'.format(x))
print(type(x))

11. 
from decimal import *
a = Decimal('.10')
b = Decimal('.30')
x = a + a + a - b 
print('x is {}'.format(x))
print(type(x))

12. 
x = True
print('x is {}'.format(x))
print(x)
print(type(x))

O / P :
x is True                                                                                                               
True                                                                                                                    
<class 'bool'> 

13. 
x = None
print('x is {}'.format(x))
print(x)
print(type(x))

O / P :
x is None                                                                                                             
None                                                                                                                  
<class 'NoneType'> 
 
14. 
x = None
print('x is {}'.format(x))
print(x)
print(type(x))

if x:
    print('True')
else:
    print('False')
	
O / P :
x is None                                                                                                             
None                                                                                                                  
<class 'NoneType'>                                                                                                    
False 

	a. None evaluates to False
	b. 0  evaluates to False
	c. Empty string evaluates to False.

15. 

Like the tuple, a range is not mutable, If I try to say X sub two equals 42,
save and run, I get this error, "TypeError: 'range' object "does not support item
assignment," because it's immutable. If I want a mutable list, I simply construct
a list with the results from range using the list constructor, like this, and save and run it.

x = range(10)
x[2] = 42
for i in x:
    print('i is {}'.format(i))
	
O / P :
Traceback (most recent call last):                                                                                    
  File "main.py", line 2, in <module>                                                                                 
    x[2] = 42                                                                                                         
TypeError: 'range' object does not support item assignment

16. And dictionaries are mutable.

17. In Python, everything is an object.

18. 
You have the following tuples. Which condition evaluates to a true statement?
 

a=('0',1,'0',[1,'0'])
b=('0',1,'0',[1,'0'])


if (type(a)==type(b)):
if (id(a[0])==id(b[2])):
all of these answers     <---
if (a==b):

19. if '0': ==> evaluates to True

20. 
Is there a difference between the strings '{1} {0}'.format('a','b') and f'{"b"} {"a"}'?

You are correct!
These strings are actually exactly the same.

21. 
x = (1, 'two', 3.0, [4, 'four'], 5)
y = (1, 'two', 3.0, [4, 'four'], 5)
print('x is {}'.format(x))
print(id(x))
print(id(y))

print(id(x[0]))
print(id(y[0]))

if isinstance(x, tuple):
    print('yep')
elif isinstance(y, list):
    print('list')
else:
    print('nope')
	
O / P :

x is (1, 'two', 3.0, [4, 'four'], 5)                                                                                  
140203163542016                                                                                                       
140203162941752                                                                                                       
10105088                                                                                                              
10105088                                                                                                              
yep

##########################################

30. If you try to access a key that doesn't exist you'll get a key error exception so
if I say print animals sub Godzilla you notice that I get the exception of key error
Godzilla because that key does not exist. Or you can use the get method to return a value
when you don't know if the key exists. I can instead say animals.get like that and I get the
none value because that key doesn't exist so if you don't want the exception, you want just
a none value, you can use the get method. So Python's dictionary type is both simple and
useful.

31. I've defined two different sets and I've defined them just using strings and when I run
this you'll notice using my print_set function below that what I get is an unordered list of
the unique characters in each string. There's no duplicates because a set does not allow
duplicates. And the lists are unordered, each time I run it you'll notice they come up in
a different order.

32. In Python, everything is an object and variables store references to objects. 

33. So let's take a look at the class constructor.
There's a special class method name called init, with double underscores before and after,
so those are two underscore characters. One and two, both before and after the word init.
And that's a special name for a class function which operates as an initializer, or a constructor.
And so you pass it three arguments, of course the first argument is always self, and that's what
makes it a method, an object method, because this self points at the object.
And then the three parameters type, name, and sound. And those are used to initialize object variables.
And these are object variables because they're never initialized until after the object is defined,
so they don't exist in the class without having been constructed into an object. And you notice that
the object variables all have an underscore at the beginning of the name. Again, this is traditional,
and this discourages users of the object from accessing these variables directly. Instead, you have
these accessors, or getters, I call them getters, some people call them accessors.
Which simply return the value of those object variables. 

34. Now you'll also notice this special method called str, with two underscores before and two underscores after. We've seen this
before, in our constructor init, with two underscores before and two underscores after. So this is a specially-named method, which
provides the string representation of the object. And this allows us to print it with simply this print and the object like that, 
without needing a special function, like we had in the previous lessons. You can find a list of all the special method names here
in the documentation, under data model. And if you click on special method names, you'll see a whole bunch of them, with all of
their descriptions. And there's str right there, the informal or nicely printable string representation of an object. And there's
just a lot more of them. There's all the comparison operators, and this list goes on for quite a while. Methods are the primary
interface for classes and objects. They work exactly like functions, except they are bound to the object through their first argument,
commonly named self.

35. So it's important to understand the distinction between class variables and object variables and how to properly encapsulate data
in your objects.

36. Iterator objects

37. it's important to note here that a string is immutable, it cannot be changed. So when you use one of these transformation methods,
the return string is a different object.

38.
In long string consisting of digits and dashes, how would you replace all dashes with spaces?
split on dashes and join on spaces

39. 
Question 2 of 3
What will the following code print?
 

a=1
b=-1
print('{1:<+04} {0:+04}'.format(a,b))

Correct answer:
-100 +001

40.
You are given two strings: s1='Test' and s2='tEST'. Which of the following conditions will be false?

You are correct!
s1.title()==s2

41. A little bit about the open function here, by default, it opens the file in read-only mode,
which would be the same as providing a mode with a R letter.

42. On line 10, I close the out file, and this is important because again, buffering, all of what we've written to the file may not
be completely written by the time our main function ends, and we want to prevent any data loss, so it's a good idea to close the file
explicitly that you've written to. You can also the close the infile. I can say, infile.close, and this is less important because
you're not going to really lose any data, and it will be closed automatically when we exit the main function. So now I'm going to
run this. You notice it happens very quickly.

43. Your environment has very limited memory. How will you prefer to copy a file of an unknown size and content in this case?

You are correct!
Use small buffers over many iterations.

44. Question 2 of 3
How can you easily check if all items in a tuple are zeros?

You are correct!
Use an any() function.

45. The expression divmod(15,2) will return a _____ with a value of _____.
tuple; (7,1)

46. How can the following line of code be useful when you're planning to use your script as a module?
 

if __name__ == '__main__':    main()

You are correct!
It allows you to test your script when running it as a stand-alone program.

47.  The Python db api is a consolidated interface for a number of database systems. It's important to understand that every database
engine has its own interface, its own requirements, and really its own paradigm, so no single interface will ever serve all of them
equally.
